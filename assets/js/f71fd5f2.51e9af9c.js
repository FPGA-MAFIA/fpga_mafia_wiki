"use strict";(self.webpackChunkmy_docs=self.webpackChunkmy_docs||[]).push([[9711],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>g});var r=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=r.createContext({}),l=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},p=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},h="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),h=l(n),d=i,g=h["".concat(c,".").concat(d)]||h[d]||u[d]||o;return n?r.createElement(g,a(a({ref:t},p),{},{components:n})):r.createElement(g,a({ref:t},p))}));function g(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,a=new Array(o);a[0]=d;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[h]="string"==typeof e?e:i,a[1]=s;for(var l=2;l<o;l++)a[l]=n[l];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},8155:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var r=n(7462),i=(n(7294),n(3905));const o={},a=void 0,s={unversionedId:"rvc/intro",id:"rvc/intro",title:"intro",description:"Making a CPU is tough work. It needs big teams to build a powerful and modern CPU, considering things like power usage, size, and speed. But all modern CPUs go through the same steps, which we'll explain here: fetching data (IF), decoding it, doing the actual work (EXE), getting data from memory (MEM-ACS), saving results (WB), and a controller that manages everything.",source:"@site/docs/rvc/intro.md",sourceDirName:"rvc",slug:"/rvc/intro",permalink:"/fpga_mafia_wiki/docs/rvc/intro",draft:!1,editUrl:"https://github.com/FPGA-MAFIA/fpga_mafia_wiki/tree/main/docs/rvc/intro.md",tags:[],version:"current",frontMatter:{},sidebar:"RISCV_Cores",next:{title:"intro",permalink:"/fpga_mafia_wiki/docs/rvc/sc_core/intro"}},c={},l=[{value:"Single Cycle",id:"single-cycle",level:3},{value:"Multi Cycle",id:"multi-cycle",level:3},{value:"Pipeline",id:"pipeline",level:3}],p={toc:l},h="wrapper";function u(e){let{components:t,...o}=e;return(0,i.kt)(h,(0,r.Z)({},p,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Making a CPU is tough work. It needs big teams to build a powerful and modern CPU, considering things like power usage, size, and speed. But all modern CPUs go through the same steps, which we'll explain here: fetching data (IF), decoding it, doing the actual work (EXE), getting data from memory (MEM-ACS), saving results (WB), and a controller that manages everything.",(0,i.kt)("br",{parentName:"p"}),"\n","The stages we mentioned don't depend on the type of ISA we pick.",(0,i.kt)("br",{parentName:"p"}),"\n","There are three main ways to make a CPU. The first one is the single cycle way, the second is the multi-cycle way, and the third is the pipeline way. The first two are not so common; we mainly use them to explain how a CPU works more simply. They can be a good way to start building a CPU if you're new to it. The third one is the most popular and used in all modern processors. Now, let's talk a bit about each of these methods."),(0,i.kt)("h1",{id:"cpu-design-approaches"},(0,i.kt)("u",null,"CPU design approaches:")),(0,i.kt)("h3",{id:"single-cycle"},"Single Cycle"),(0,i.kt)("p",null,"A single-cycle processor executes one instruction in a single clock cycle. It fetches, decodes, performs the operation, and writes back the result in a single step. This approach is simple to understand but not very efficient mostly because the data-path is very long and the clock cycle is determined by the longest instruction causing to low frequency, low throughput and high latency.    "),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"You may refer to the following figure to see how a single cycle processor works. To see the code for this processor, you can go to the ",(0,i.kt)("inlineCode",{parentName:"li"},"sources")," folder in the ",(0,i.kt)("inlineCode",{parentName:"li"},"sc_core")," folder."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"sc_core")," based on the following diagram:   ")),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"sc_core.png",src:n(5224).Z,width:"887",height:"523"})),(0,i.kt)("h3",{id:"multi-cycle"},"Multi Cycle"),(0,i.kt)("p",null,"A multi-cycle processor breaks instruction execution into multiple clock cycles, with each cycle handling a specific task (e.g., fetch, decode, execute). This approach is more complex but allows for more efficient use of hardware resources because the data-path is shorter and the clock cycle is determined by the longest stage. This approach is more efficient than the single cycle approach but still not very efficient because the clock cycle is determined by the longest instruction."),(0,i.kt)("h3",{id:"pipeline"},"Pipeline"),(0,i.kt)("p",null,"A pipelined processor is a complex design that enhances CPU efficiency by allowing multiple instructions to be processed concurrently, in a staged manner. Here's a detailed explanation of how it works:"),(0,i.kt)("p",null,"Pipeline Stages: The CPU is divided into several stages, typically five: Fetch, Decode, Execute, Memory, and Write-Back. Each stage performs a specific part of the instruction processing."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Instruction Fetch (IF):"),"\nThe first stage fetches the next instruction from memory.\nWhile one instruction is being fetched, the previous one can move on to the decode stage."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Instruction Decode (ID):"),"\nIn this stage, the CPU decodes the fetched instruction to determine what operation it represents and identifies the required registers.\nMeanwhile, the previous instruction moves to the execute stage, and the next instruction is fetched."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Execution (EXE):"),"\nThis stage performs the actual operation specified by the instruction.\nSimultaneously, the previous instruction proceeds to the memory access stage, the one before that goes to the write-back stage, and the next instruction enters the decode stage.\nMemory Access (MEM):"),(0,i.kt)("p",null,"If the instruction involves memory operations, like reading or writing to memory, this stage handles them.\nAt the same time, the previous instruction moves to the write-back stage, and the one before it advances to the memory stage."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Write-Back (WB):"),"\nIn this stage, the CPU writes the results of the executed instruction back to the appropriate registers.\nThe previous instruction may retire (complete its execution), and the next instruction enters the decode stage."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Stall and Bypass:"),'\nTo handle data dependencies or hazards (situations where an instruction depends on the result of a previous instruction), the pipeline can "stall" or "bypass" data from previous stages to ensure proper sequencing.\nContinuous Flow:'),(0,i.kt)("p",null,"The key advantage of pipelining is that each stage operates concurrently, so while one instruction is in the execute stage, another is in the decode stage, and a third is being fetched. This overlapping of tasks leads to better CPU throughput and overall performance.\nHazards:"),(0,i.kt)("p",null,"Although pipelining enhances performance, it can also introduce issues like data hazards (when one instruction relies on data produced by a previous instruction) and control hazards (when a branch instruction changes the program flow). These must be managed through techniques like forwarding, speculative execution, or stalling.\nIn a well-designed pipeline, the CPU can process several instructions at the same time, significantly increasing its overall performance and throughput. However, handling hazards and ensuring instructions are processed in the correct order are key challenges in pipelined processor design.   "),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"You may refer to the following figure to see how a single cycle processor works. To see the code for this processor, you can go to the ",(0,i.kt)("inlineCode",{parentName:"li"},"sources")," folder in the ",(0,i.kt)("inlineCode",{parentName:"li"},"mini_core")," folder."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"5_stage_core")," based on the following diagram: ")),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"5_stage_core.png",src:n(8046).Z,width:"1281",height:"488"})),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"for additional information about the pipeline and how to build a CPU, you can go to:")," ",(0,i.kt)("inlineCode",{parentName:"p"},"orig_docs")," -> ",(0,i.kt)("inlineCode",{parentName:"p"},"CPU_Arch")," folder in the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/amichai-bd/fpga_mafia_wiki"},"GitHub-Wiki")," repository"))}u.isMDXComponent=!0},8046:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/5_stage_core-eb62619467e93ff04332c367b82a01e4.png"},5224:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/sc_core-4b3b8cb9aaba4f51ca5bc10bd750fd24.png"}}]);