"use strict";(self.webpackChunkmy_docs=self.webpackChunkmy_docs||[]).push([[2639],{3905:(e,t,r)=>{r.d(t,{Zo:()=>c,kt:()=>u});var a=r(7294);function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function n(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?n(Object(r),!0).forEach((function(t){i(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):n(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,a,i=function(e,t){if(null==e)return{};var r,a,i={},n=Object.keys(e);for(a=0;a<n.length;a++)r=n[a],t.indexOf(r)>=0||(i[r]=e[r]);return i}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(a=0;a<n.length;a++)r=n[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var s=a.createContext({}),d=function(e){var t=a.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},c=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},g="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var r=e.components,i=e.mdxType,n=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),g=d(r),m=i,u=g["".concat(s,".").concat(m)]||g[m]||p[m]||n;return r?a.createElement(u,o(o({ref:t},c),{},{components:r})):a.createElement(u,o({ref:t},c))}));function u(e,t){var r=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var n=r.length,o=new Array(n);o[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[g]="string"==typeof e?e:i,o[1]=l;for(var d=2;d<n;d++)o[d]=r[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,r)}m.displayName="MDXCreateElement"},1865:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>p,frontMatter:()=>n,metadata:()=>l,toc:()=>d});var a=r(7462),i=(r(7294),r(3905));const n={},o=void 0,l={unversionedId:"rvc/common/rf",id:"rvc/common/rf",title:"rf",description:"Register File",source:"@site/docs/rvc/common/rf.md",sourceDirName:"rvc/common",slug:"/rvc/common/rf",permalink:"/fpga_mafia_wiki/docs/rvc/common/rf",draft:!1,editUrl:"https://github.com/FPGA-MAFIA/fpga_mafia_wiki/tree/main/docs/rvc/common/rf.md",tags:[],version:"current",frontMatter:{},sidebar:"RISCV_Cores",previous:{title:"decode",permalink:"/fpga_mafia_wiki/docs/rvc/common/decode"},next:{title:"exe",permalink:"/fpga_mafia_wiki/docs/rvc/common/exe"}},s={},d=[{value:"Register File",id:"register-file",level:2},{value:"Instantiation of register file in mini_core.sv",id:"instantiation-of-register-file-in-mini_coresv",level:3},{value:"Signal description",id:"signal-description",level:3},{value:"Register file module mini_core_rf.sv",id:"register-file-module-mini_core_rfsv",level:3},{value:"Module Signal description",id:"module-signal-description",level:3},{value:"Forwarding in register file",id:"forwarding-in-register-file",level:3},{value:"mini_core_rf module abstract diagram",id:"mini_core_rf-module-abstract-diagram",level:3}],c={toc:d},g="wrapper";function p(e){let{components:t,...n}=e;return(0,i.kt)(g,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"register-file"},"Register File"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Register file is a collection of registers. In RV32I there are 32 registers and in RV32E there are 16 registers, Each register is 32 bits wide. Number of registers can be changed by changing the ",(0,i.kt)("inlineCode",{parentName:"li"},"RF_NUM_MSB")," parameter.   "),(0,i.kt)("li",{parentName:"ul"},"The register file has two read ports and one write port."),(0,i.kt)("li",{parentName:"ul"},"Register file is a part of second stage of the pipeline named ",(0,i.kt)("inlineCode",{parentName:"li"},"CYCLE Q101H"),".")),(0,i.kt)("h3",{id:"instantiation-of-register-file-in-mini_coresv"},"Instantiation of register file in mini_core.sv"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"mini_core_rf \n#( .RF_NUM_MSB(RF_NUM_MSB) )    \nmini_core_rf (\n  .Clock            (Clock),          // input\n  .Rst              (Rst),            // input \n  .Ctrl             (CtrlRf),         // input\n  .ReadyQ102H       (ReadyQ102H),     // input\n  // input data path\n  .ImmediateQ101H   (ImmediateQ101H), // input\n  .PcQ101H          (PcQ101H),        // input  \n  .RegWrDataQ104H   (RegWrDataQ104H), // input \n  // output data path\n  .PcQ102H          (PcQ102H),        // output   \n  .ImmediateQ102H   (ImmediateQ102H), // output\n  .RegRdData1Q102H  (RegRdData1Q102H),// output\n  .RegRdData2Q102H  (RegRdData2Q102H) // output\n);\n")),(0,i.kt)("h3",{id:"signal-description"},"Signal description"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"CtrlRf: This is a part of ",(0,i.kt)("inlineCode",{parentName:"li"},"typedef struct packed named t_ctrl_rf")," (see mini_core_pkg.vh file) variable.   "),(0,i.kt)("li",{parentName:"ul"},"ImmediateQ101H: Immediate value of instruction."),(0,i.kt)("li",{parentName:"ul"},"ImmediateQ102H: Immediate value of instruction passed to the next stage of pipeline through ID/EX register."),(0,i.kt)("li",{parentName:"ul"},"PcQ101H: Program counter value of instruction from previous stage of pipeline (Q100H)."),(0,i.kt)("li",{parentName:"ul"},"PcQ102H: Program counter value of instruction passed to the next stage of pipeline through ID/EX register."),(0,i.kt)("li",{parentName:"ul"},"RegRdData1Q102H: Register read data 1 value of instruction passed to the next stage of pipeline through ID/EX register."),(0,i.kt)("li",{parentName:"ul"},"RegRdData2Q102H: Register read data 2 value of instruction passed to the next stage of pipeline through ID/EX register.")),(0,i.kt)("h3",{id:"register-file-module-mini_core_rfsv"},"Register file module mini_core_rf.sv"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"`include \"macros.sv\"\n\nmodule mini_core_rf \nimport common_pkg::*;\n#(parameter RF_NUM_MSB) \n(\n    input logic Clock,\n    input logic Rst,\n    // input control path\n    input var t_ctrl_rf Ctrl,\n    // input data path\n    input  logic        ReadyQ102H,\n    input  logic [31:0] PcQ101H,\n    input  logic [31:0] ImmediateQ101H,\n    input  logic [31:0] RegWrDataQ104H,\n    // output data path\n    output logic [31:0] PcQ102H,\n    output logic [31:0] ImmediateQ102H,\n    output logic [31:0] RegRdData1Q102H,\n    output logic [31:0] RegRdData2Q102H\n);\n\n\nlogic [RF_NUM_MSB:1][31:0]  Register;\nlogic                       MatchRd1AftrWrQ101H;\nlogic                       MatchRd2AftrWrQ101H;\nlogic [31:0]                RegRdData1Q101H;\nlogic [31:0]                RegRdData2Q101H;\n//===================\n//  Register File\n//===================\n//---- The Register File ----\n `MAFIA_EN_DFF(Register[Ctrl.RegDstQ104H] , RegWrDataQ104H , Clock , (Ctrl.RegWrEnQ104H && (Ctrl.RegDstQ104H!=5'b0)))\n// ---- Read Register File ----\nassign MatchRd1AftrWrQ101H = (Ctrl.RegSrc1Q101H == Ctrl.RegDstQ104H) && (Ctrl.RegWrEnQ104H);\nassign RegRdData1Q101H = (Ctrl.RegSrc1Q101H == 5'b0) ? 32'b0                      : // Reading from Register[0] should result in '0\n                         MatchRd1AftrWrQ101H         ? RegWrDataQ104H             : // forwards WrDataQ104H -> RdDataQ101H\n                                                       Register[Ctrl.RegSrc1Q101H]; // Common Case - reading from Register file\n\nassign MatchRd2AftrWrQ101H = (Ctrl.RegSrc2Q101H == Ctrl.RegDstQ104H) && (Ctrl.RegWrEnQ104H);\nassign RegRdData2Q101H = (Ctrl.RegSrc2Q101H == 5'b0) ? 32'b0                      : // Reading from Register[0] should result in '0 \n                         MatchRd2AftrWrQ101H         ? RegWrDataQ104H             : // forwards WrDataQ104H -> RdDataQ101H\n                                                       Register[Ctrl.RegSrc2Q101H]; // Common Case - reading from Register file\n\n`MAFIA_EN_DFF(ImmediateQ102H,  ImmediateQ101H,  Clock, ReadyQ102H)\n`MAFIA_EN_DFF(PcQ102H,         PcQ101H,         Clock, ReadyQ102H)\n`MAFIA_EN_DFF(RegRdData1Q102H, RegRdData1Q101H, Clock, ReadyQ102H)\n`MAFIA_EN_DFF(RegRdData2Q102H, RegRdData2Q101H, Clock, ReadyQ102H)\n\nendmodule\n")),(0,i.kt)("h3",{id:"module-signal-description"},"Module Signal description"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"logic [RF_NUM_MSB:1][31:0]  Register")," - Register file. We actually possess 31 registers rather than 32, as reg0 is consistently reserved as zero."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"logic                       MatchRd1AftrWrQ101H")," - This signal is used to determine whether the register read data 1 is the same as the register write data. If it is, then the register read data 1 is forwarded from the register write data."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"logic                       MatchRd2AftrWrQ101H")," - This signal is used to determine whether the register read data 2 is the same as the register write data. If it is, then the register "),(0,i.kt)("li",{parentName:"ul"},"Other signals are self explanatory. You may use the figure below to understand the flow of data in the register file.")),(0,i.kt)("h3",{id:"forwarding-in-register-file"},"Forwarding in register file"),(0,i.kt)("p",null,"Forwarding in register file occurs when the register read data at decode stage (Q101H) is the same as the register write data at WB stage (Q104H) meaning that the read data is not ready yet. In this case, we forward data from Q104H stage directly to Q101H stage. This is done by the following code: (example for register read data 1)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"assign MatchRd1AftrWrQ101H = (Ctrl.RegSrc1Q101H == Ctrl.RegDstQ104H) && (Ctrl.RegWrEnQ104H);\nassign RegRdData1Q101H = (Ctrl.RegSrc1Q101H == 5'b0) ? 32'b0                      : // Reading from Register[0] should result in '0\n                         MatchRd1AftrWrQ101H         ? RegWrDataQ104H             : // forwards WrDataQ104H -> RdDataQ101H\n                                                       Register[Ctrl.RegSrc1Q101H]; // Common Case - reading from Register file\n")),(0,i.kt)("p",null,"This can happen for example in the following case:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"add x1, x2, x3 (Q104H)\nadd x4, x5, x6 (Q103H)\nadd x7, x8, x9 (Q102H)\nadd x10, x1, x11 (Q101H)\n")),(0,i.kt)("p",null,"We need data of ",(0,i.kt)("inlineCode",{parentName:"p"},"x1")," in Q101H stage, but it is not ready yet. So we forward the data from Q104H stage to Q101H stage."),(0,i.kt)("h3",{id:"mini_core_rf-module-abstract-diagram"},"mini_core_rf module abstract diagram"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"---------------------------------------------------------------------------------------------------------------------------------------")),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"rf",src:r(1503).Z,width:"1482",height:"1212"})),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"---------------------------------------------------------------------------------------------------------------------------------------")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Please note that the above implementation behaves correctly but the real hardware implementation can be changed depending on the synthesis tool you use.")))}p.isMDXComponent=!0},1503:(e,t,r)=>{r.d(t,{Z:()=>a});const a=r.p+"assets/images/rf-2d9e3bafb2b48b14dc897692a71e7e84.jpg"}}]);