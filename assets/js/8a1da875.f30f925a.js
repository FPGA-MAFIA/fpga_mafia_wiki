"use strict";(self.webpackChunkmy_docs=self.webpackChunkmy_docs||[]).push([[3089],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=a.createContext({}),s=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=s(e.components);return a.createElement(c.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,c=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=s(n),m=i,h=d["".concat(c,".").concat(m)]||d[m]||p[m]||r;return n?a.createElement(h,o(o({ref:t},u),{},{components:n})):a.createElement(h,o({ref:t},u))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=m;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l[d]="string"==typeof e?e:i,o[1]=l;for(var s=2;s<r;s++)o[s]=n[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},7631:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>r,metadata:()=>l,toc:()=>s});var a=n(7462),i=(n(7294),n(3905));const r={},o=void 0,l={unversionedId:"rvc/sc_core/sc_core",id:"rvc/sc_core/sc_core",title:"sc_core",description:"sc_core.sv file",source:"@site/docs/rvc/sc_core/sc_core.md",sourceDirName:"rvc/sc_core",slug:"/rvc/sc_core/",permalink:"/fpga_mafia_wiki/docs/rvc/sc_core/",draft:!1,editUrl:"https://github.com/FPGA-MAFIA/fpga_mafia_wiki/tree/main/docs/rvc/sc_core/sc_core.md",tags:[],version:"current",frontMatter:{},sidebar:"RISCV_Cores",previous:{title:"sc_core_pkg",permalink:"/fpga_mafia_wiki/docs/rvc/sc_core/sc_core_pkg"},next:{title:"The Mini Core",permalink:"/fpga_mafia_wiki/docs/rvc/common/intro"}},c={},s=[{value:"sc_core.sv file",id:"sc_coresv-file",level:3},{value:"module signals",id:"module-signals",level:3},{value:"interface with instruction memory",id:"interface-with-instruction-memory",level:4},{value:"interface with data memory",id:"interface-with-data-memory",level:4},{value:"Signal declaration",id:"signal-declaration",level:3},{value:"Instruction fetch",id:"instruction-fetch",level:3},{value:"Instruction Decode part 1",id:"instruction-decode-part-1",level:3},{value:"Instruction Decode part 2",id:"instruction-decode-part-2",level:3},{value:"Instruction Decode part 3",id:"instruction-decode-part-3",level:3},{value:"Instruction Decode part 4 - Register file",id:"instruction-decode-part-4---register-file",level:3},{value:"Execution stage",id:"execution-stage",level:3},{value:"Memory Access",id:"memory-access",level:3},{value:"Write back stage",id:"write-back-stage",level:3}],u={toc:s},d="wrapper";function p(e){let{components:t,...n}=e;return(0,i.kt)(d,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h3",{id:"sc_coresv-file"},"sc_core.sv file"),(0,i.kt)("p",null,"Now we are going to look at the ",(0,i.kt)("inlineCode",{parentName:"p"},"sc_core.sv")," file. That file is located at ",(0,i.kt)("inlineCode",{parentName:"p"},"/source/sc_core/sc_core.sv")," folder.  "),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Please use the figure ",(0,i.kt)("a",{parentName:"li",href:"/fpga_mafia_wiki/docs/rvc/sc_core/intro"},"here")," to understand the cpu stages.")),(0,i.kt)("h3",{id:"module-signals"},"module signals"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'//-----------------------------------------------------------------------------\n// Title            : single cycle core design\n// Project          : \n//-----------------------------------------------------------------------------\n// File             : \n// Original Author  : Amichai Ben-David\n// Code Owner       : \n// Created          : 11/2022\n//-----------------------------------------------------------------------------\n// Description :\n// This is the top level of the single cycle core design.\n// The core is a 32 bit RISC-V core.\n// compatible with the RV32I base instruction set.\n// Fetch, Decode, Execute, Memory, WriteBack all in one cycle.\n// The PC (program counter) is the synchronous element in the core \n//-----------------------------------------------------------------------------\n`include "macros.sv"\n\nmodule sc_core\nimport sc_core_pkg::*;\n(\n    input logic Clk,\n    input logic Rst,\n    // interface with instruction memory\n    output logic [31:0] Pc,\n    input  logic [31:0] Instruction,\n    // interface with Data Memory\n    output logic [31:0] DMemAddress,\n    output logic [31:0] DMemData   ,\n    output logic [3:0]  DMemByteEn ,\n    output logic        DMemWrEn   ,\n    output logic        DMemRdEn   ,\n    input  logic [31:0] DMemRspData\n);\n')),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Clk")," - core clock\n",(0,i.kt)("inlineCode",{parentName:"p"},"Rst")," - core reset. We use that signal to reset Pc to 0."),(0,i.kt)("h4",{id:"interface-with-instruction-memory"},"interface with instruction memory"),(0,i.kt)("p",null,"Pc value is sended to the instruction memory. The instruction memory returns the instruction that is located at the Pc address. Because the core is a single cycle the memory read must be asynchronous.    "),(0,i.kt)("p",null,"Instruction memory Granularity is 8-bit."),(0,i.kt)("h4",{id:"interface-with-data-memory"},"interface with data memory"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"DMemAddress")," - address to the data memory"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"DMemData")," - data to be written to the data memory"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"DMemByteEn")," - byte enable to the data memory. used for byte and half word instructions"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"DMemWrEn")," - write enable to the data memory"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"DMemRdEn")," - read enable to the data memory"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"DMemRspData")," - data that is read from the data memory   ")),(0,i.kt)("p",null,"Data memory Granularity is 8-bit."),(0,i.kt)("h3",{id:"signal-declaration"},"Signal declaration"),(0,i.kt)("p",null,"There in no need to explain the signal declaration and the best way to understand what each signal does is to look at the code and the figure ",(0,i.kt)("a",{parentName:"p",href:"/fpga_mafia_wiki/docs/rvc/sc_core/intro"},"here"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// signal declination\n//Data-Path signals\nlogic [31:0]        NextPc;\nlogic [31:0]        PcPlus4;\nlogic [31:1][31:0]  Register; \nlogic [31:0]        Immediate;\nlogic [4:0]         Shamt;\nlogic [31:0]        PreDMemRdData;\nlogic [31:0]        AluIn1; \nlogic [31:0]        AluIn2; \nlogic [31:0]        AluOut;\nlogic [31:0]        RegRdData1; \nlogic [31:0]        RegRdData2; \nlogic [31:0]        RegWrData; \nlogic [31:0]        WrBackData;\n//Ctrl Bits\nlogic               SelNextPcAluOut;\nlogic               SelRegWrPc; \nlogic               BranchCondMet;\nlogic               SelDMemWb;\nlogic               CtrlLui;\nlogic               CtrlRegWrEn;\nlogic [2:0]         Funct3;\nlogic [6:0]         Funct7;\nlogic [4:0]         RegSrc1, RegSrc2, RegDst;\nlogic [3:0]         CtrlDMemByteEn;\nlogic               CtrlDMemWrEn;\nlogic               CtrlSignExt;\nlogic               SelAluPc ;\nlogic               SelAluImm;\nt_immediate         SelImmType;\nt_alu_op            CtrlAluOp;\nt_branch_type       CtrlBranchOp;\nt_opcode            Opcode;\n")),(0,i.kt)("h3",{id:"instruction-fetch"},"Instruction fetch"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"//===========================================================================\n// Instruction fetch\n// 1. Send the PC (Program Counter) to the I_MEM.\n// 2. Set the Next Pc -> Pc+4 or Calculated Address.\n//===========================================================================\nassign PcPlus4  = Pc + 32'd4;\nassign NextPc   = SelNextPcAluOut ? AluOut : PcPlus4;\n`MAFIA_RST_DFF( Pc, NextPc , Clk, Rst )\n")),(0,i.kt)("p",null,"That block is responsible for fetching the instruction from the instruction memory. Pc can be changed by the ",(0,i.kt)("inlineCode",{parentName:"p"},"JAL/JALR/BRANCH")," instruction calculated in the execute stage or incremented by 4 in the case of a normal instruction. "),(0,i.kt)("h3",{id:"instruction-decode-part-1"},"Instruction Decode part 1"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"\n//===========================================================================\n// Decode\n// 1. Get the instruction from I_MEM and use the \"decoder\" to set the Ctrl Bits.\n// 2. Construct the Immediate types.\n// 3. Use the RS1 & RS2 (RegSrc) to read the Register file data.\n//===========================================================================\nassign Opcode = t_opcode'(Instruction[6:0]);\nassign Funct3 = Instruction[14:12];\nassign Funct7 = Instruction[31:25];\n\nassign SelNextPcAluOut = (Opcode == JAL) || (Opcode == JALR) || ((Opcode == BRANCH) & (BranchCondMet));\nassign SelRegWrPc      = (Opcode == JAL) || (Opcode == JALR);\nassign SelAluImm       = !(Opcode == R_OP);\nassign SelAluPc        = (Opcode == JAL) || (Opcode == BRANCH) || (Opcode == AUIPC);\nassign SelDMemWb       = (Opcode == LOAD);\nassign CtrlRegWrEn     = (Opcode == LUI ) || (Opcode == AUIPC) || (Opcode == JAL)  || (Opcode == JALR) ||\n                         (Opcode == LOAD) || (Opcode == I_OP)  || (Opcode == R_OP) || (Opcode == FENCE);\nassign CtrlDMemWrEn    = (Opcode == STORE);\nassign CtrlSignExt     = (Opcode == LOAD) & (!Funct3[2]);                     \nassign CtrlDMemByteEn  = ((Opcode == LOAD) || (Opcode == STORE)) && (Funct3[1:0] == 2'b00) ? 4'b0001 :// LB || SB\n                         ((Opcode == LOAD) || (Opcode == STORE)) && (Funct3[1:0] == 2'b01) ? 4'b0011 :// LH || SH\n                         ((Opcode == LOAD) || (Opcode == STORE)) && (Funct3[1:0] == 2'b10) ? 4'b1111 :// LW || SW\n                                                                                            4'b0000 ;                      \nassign CtrlBranchOp    = t_branch_type'(Funct3);  \nassign SimulationDone  = (Opcode == SYSCAL);\n")),(0,i.kt)("p",null,"The most interesting part here is the ",(0,i.kt)("inlineCode",{parentName:"p"},"assign Opcode = t_opcode'(Instruction[6:0]);"),", because every thing else is relatively intuitive.   "),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"t_opcode")," is an enum that is defined in the ",(0,i.kt)("inlineCode",{parentName:"p"},"sc_core_pkg.sv")," file.   ",(0,i.kt)("inlineCode",{parentName:"p"},"Opcode")," is defined in previous section and it can be one of the following values: ",(0,i.kt)("inlineCode",{parentName:"p"},"LUI, AUIPC, JAL, JALR, BRANCH, LOAD, STORE, I_OP, R_OP, FENCE, SYSCAL"),". "),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Instruction[6:0]")," is a value that represents the opcode of the instruction, because its type is logic, we need to make  ",(0,i.kt)("strong",{parentName:"p"},"casting")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"t_opcode")," type. We do that by adding the\n",(0,i.kt)("strong",{parentName:"p"},"t_opcode'")," casting operator."),(0,i.kt)("h3",{id:"instruction-decode-part-2"},"Instruction Decode part 2"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"always_comb begin\n    unique casez ({Funct3, Funct7, Opcode})\n    //-----LUI type-------\n    {3'b???, 7'b???????, LUI } : CtrlAluOp = IN_2;//LUI\n    //-----R type-------\n    {3'b000, 7'b0000000, R_OP} : CtrlAluOp = ADD; //ADD\n    {3'b000, 7'b0100000, R_OP} : CtrlAluOp = SUB; //SUB\n    {3'b001, 7'b0000000, R_OP} : CtrlAluOp = SLL; //SLL\n    {3'b010, 7'b0000000, R_OP} : CtrlAluOp = SLT; //SLT\n    {3'b011, 7'b0000000, R_OP} : CtrlAluOp = SLTU;//SLTU\n    {3'b100, 7'b0000000, R_OP} : CtrlAluOp = XOR; //XOR\n    {3'b101, 7'b0000000, R_OP} : CtrlAluOp = SRL; //SRL\n    {3'b101, 7'b0100000, R_OP} : CtrlAluOp = SRA; //SRA\n    {3'b110, 7'b0000000, R_OP} : CtrlAluOp = OR;  //OR\n    {3'b111, 7'b0000000, R_OP} : CtrlAluOp = AND; //AND\n    //-----I type-------\n    {3'b000, 7'b???????, I_OP} : CtrlAluOp = ADD; //ADDI\n    {3'b010, 7'b???????, I_OP} : CtrlAluOp = SLT; //SLTI\n    {3'b011, 7'b???????, I_OP} : CtrlAluOp = SLTU;//SLTUI\n    {3'b100, 7'b???????, I_OP} : CtrlAluOp = XOR; //XORI\n    {3'b110, 7'b???????, I_OP} : CtrlAluOp = OR;  //ORI\n    {3'b111, 7'b???????, I_OP} : CtrlAluOp = AND; //ANDI\n    {3'b001, 7'b0000000, I_OP} : CtrlAluOp = SLL; //SLLI\n    {3'b101, 7'b0000000, I_OP} : CtrlAluOp = SRL; //SRLI\n    {3'b101, 7'b0100000, I_OP} : CtrlAluOp = SRA; //SRAI\n    //-----Other-------\n    default                    : CtrlAluOp = ADD; //AUIPC || JAL || JALR || BRANCH || LOAD || STORE\n    endcase\nend\n")),(0,i.kt)("p",null,"That code defines a combinational logic block using the ",(0,i.kt)("inlineCode",{parentName:"p"},"always_comb")," keyword. The code is using a case statement to determine the value of CtrlAluOp based on the values of ",(0,i.kt)("inlineCode",{parentName:"p"},"Funct3, Funct7, and Opcode"),". "),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The always_comb block indicates that this logic should always be computed whenever the inputs change.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"`unique casez`` is a unique case statement that allows for the most specific match to be used, meaning that if multiple conditions match, only the first one encountered will be executed.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Inside the case block, the code checks various combinations of ",(0,i.kt)("inlineCode",{parentName:"p"},"Funct3, Funct7"),", and Opcode values using pattern matching."))),(0,i.kt)("p",null,"Depending on the values of these inputs, different values are assigned to the CtrlAluOp variable, which is used in further logic or hardware."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"For example, if Funct3 is 3'b???', Funct7 is 7'b???????, and Opcode is LUI, then CtrlAluOp is set to IN_2.")),(0,i.kt)("p",null,"The default case at the end of the case block specifies what happens when none of the specified conditions match. In this case, CtrlAluOp is set to ADD."),(0,i.kt)("h3",{id:"instruction-decode-part-3"},"Instruction Decode part 3"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"//  Immediate Generator\nalways_comb begin\n    unique casez (Opcode)    //mux\n    JALR, I_OP, LOAD : SelImmType = I_TYPE;\n    LUI, AUIPC       : SelImmType = U_TYPE;\n    JAL              : SelImmType = J_TYPE;\n    BRANCH           : SelImmType = B_TYPE;\n    STORE            : SelImmType = S_TYPE;\n    default          : SelImmType = I_TYPE;\n  endcase\n  unique casez (SelImmType)    //mux\n    U_TYPE : Immediate = {     Instruction[31:12], 12'b0 } ;                                                            //U_Immediate;\n    I_TYPE : Immediate = { {20{Instruction[31]}} , Instruction[31:20] };                                                //I_Immediate;\n    S_TYPE : Immediate = { {20{Instruction[31]}} , Instruction[31:25] , Instruction[11:7]  };                           //S_Immediate;\n    B_TYPE : Immediate = { {20{Instruction[31]}} , Instruction[7]     , Instruction[30:25] , Instruction[11:8]  , 1'b0};//B_Immediate;\n    J_TYPE : Immediate = { {12{Instruction[31]}} , Instruction[19:12] , Instruction[20]    , Instruction[30:21] , 1'b0};//J_Immediate;\n    default: Immediate = {     Instruction[31:12], 12'b0 };                                                             //U_Immediate;\n  endcase\nend                \n")),(0,i.kt)("p",null,"This code defines a combinational logic block using the always_comb keyword. It determines the value of SelImmType based on the Opcode and then computes the Immediate value based on the selected SelImmType. Here's an explanation:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The first casez (Opcode) block checks the value of Opcode and assigns a value to SelImmType based on its value.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Depending on the value of Opcode, it selects one of several instruction types (U_TYPE, I_TYPE, S_TYPE, B_TYPE, or J_TYPE). If none of the specific conditions match, it sets SelImmType to I_TYPE by default.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The second casez (SelImmType) block uses the selected SelImmType to determine how to compute the Immediate value for the instruction.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"It assigns the appropriate value to Immediate based on the instruction type. Each type corresponds to a different way of forming the immediate value for the instruction.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For example, when SelImmType is U_TYPE, it forms the Immediate value by taking bits from the Instruction array in a specific pattern. The same logic applies to the other instruction types as well."))),(0,i.kt)("h3",{id:"instruction-decode-part-4---register-file"},"Instruction Decode part 4 - Register file"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"//===================\n//  Register File\n//===================\nassign RegDst  = Instruction[11:7];\nassign RegSrc1 = Instruction[19:15];\nassign RegSrc2 = Instruction[24:20];\n// --- Select what Write to register file --------\nassign RegWrData = SelRegWrPc ? PcPlus4 : WrBackData; \n//---- The Register File  ------\n`MAFIA_EN_DFF(Register[RegDst] , RegWrData , Clk , (CtrlRegWrEn && (RegDst!=5'b0)))\n// --- read Register File --------\nassign RegRdData1 = (RegSrc1==5'b0) ? 32'b0 : Register[RegSrc1];\nassign RegRdData2 = (RegSrc2==5'b0) ? 32'b0 : Register[RegSrc2];\n")),(0,i.kt)("h3",{id:"execution-stage"},"Execution stage"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"//===========================================================================\n// Execute\n// 1. Compute Data to write back to register.\n// 2. Compute Address for load/store\n// 3. Compute Branch/Jump address target. (set PC)\n// 4. Check branch condition\n//===========================================================================\nassign AluIn1 = SelAluPc    ? Pc        : RegRdData1;\nassign AluIn2 = SelAluImm   ? Immediate : RegRdData2;\n\nalways_comb begin : alu_logic\n    Shamt = AluIn2[4:0]; \n    //According to ALU OP we select the correct operation\n    unique casez (CtrlAluOp)\n        ADD      :   AluOut = AluIn1 + AluIn2                  ;\n        SUB      :   AluOut = AluIn1 + (~AluIn2) + 1'b1        ;\n        //shift\n        SLL     : AluOut = AluIn1 << Shamt                     ;//SLL\n        SRL     : AluOut = AluIn1 >> Shamt                     ;//SRL\n        SRA     : AluOut = $signed(AluIn1) >>> Shamt           ;//SRA\n        //bit wise operations\n        XOR     : AluOut = AluIn1 ^ AluIn2                     ;//XOR\n        OR      : AluOut = AluIn1 | AluIn2                     ;//OR\n        AND     : AluOut = AluIn1 & AluIn2                     ;//AND\n        IN_2    : AluOut = AluIn2                              ;//LUI\n        SLT     : AluOut = $signed(AluIn1) < $signed(AluIn2)   ;//SLT\n        SLTU    : AluOut = AluIn1 < AluIn2                     ;//SLTU\n        default : AluOut = AluIn1 + AluIn2                     ;\n  endcase\nend\n\nalways_comb begin : branch_comp\n  //for branch condition.\n  unique casez ({CtrlBranchOp})\n    BEQ     : BranchCondMet =  (RegRdData1==RegRdData2)                   ;// BEQ\n    BNE     : BranchCondMet = ~(RegRdData1==RegRdData2)                   ;// BNE\n    BLT     : BranchCondMet =  ($signed(RegRdData1)<$signed(RegRdData2))  ;// BLT\n    BGE     : BranchCondMet = ~($signed(RegRdData1)<$signed(RegRdData2))  ;// BGE\n    BLTU    : BranchCondMet =  (RegRdData1<RegRdData2)                    ;// BLTU\n    BGEU    : BranchCondMet = ~(RegRdData1<RegRdData2)                    ;// BGEU\n    default : BranchCondMet = 1'b0                                        ;\n  endcase\nend\n")),(0,i.kt)("p",null,"This is the execution stage, including computing values for write-back to registers, load/store addresses, branch/jump target addresses, and checking branch conditions."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The code assigns values to AluIn1 and AluIn2 based on certain conditions. AluIn1 is assigned either the PC or the value from RegRdData1, and AluIn2 is assigned either the Immediate value or RegRdData2. These assignments depend on the values of SelAluPc and SelAluImm.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The always_comb block with the label alu_logic calculates the result of the ALU (Arithmetic Logic Unit) operation based on the CtrlAluOp control signal. The specific operation performed depends on the value of CtrlAluOp. Common ALU operations like addition (ADD), subtraction (SUB), bitwise operations, and shifts are implemented here.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The always_comb block labeled branch_comp computes the branch condition (BranchCondMet) based on the control signal CtrlBranchOp. The type of branch comparison depends on the value of CtrlBranchOp and includes conditions such as equal (BEQ), not equal (BNE), less than (BLT), greater than or equal to (BGE), and unsigned comparisons (BLTU and BGEU). The result of the comparison is assigned to BranchCondMet."))),(0,i.kt)("h3",{id:"memory-access"},"Memory Access"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"//===========================================================================\n// Memory Access\n// Access D_MEM for Write (STORE) and Reads (LOAD). \u2013 use Byte Enable and Sign-Extend indications.\n//===========================================================================\n\n// Both RD & WR\nassign DMemAddress  = AluOut;\nassign DMemByteEn   = CtrlDMemByteEn;\n//WR\nassign DMemData     = RegRdData2;\nassign DMemWrEn     = CtrlDMemWrEn;\n//RD\nassign DMemRdEn     = SelDMemWb;\n")),(0,i.kt)("p",null,"This part calculates the address of the data memory and the byte enable signal. It also sets the data to be written to the data memory and the write enable signal. Finally, it sets the read enable signal based on the value of SelDMemWb."),(0,i.kt)("h3",{id:"write-back-stage"},"Write back stage"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"//===========================================================================\n// Write-Back\n//===========================================================================\n// -----------------\n// 1. Select which data should be written back to the register file AluOut or DMemRdData.\n// Sign extend taking care of\nlogic [31:0] DMemRspDataBeSx;\nassign DMemRspDataBeSx[7:0]   =  CtrlDMemByteEn[0] ? DMemRspData[7:0]     : 8'b0;\nassign DMemRspDataBeSx[15:8]  =  CtrlDMemByteEn[1] ? DMemRspData[15:8]    :\n                                 CtrlSignExt       ? {8{WrBackData[7]}} : 8'b0;\nassign DMemRspDataBeSx[23:16] =  CtrlDMemByteEn[2] ? DMemRspData[23:16]:\n                                 CtrlSignExt       ? {8{WrBackData[15]}}: 8'b0;\nassign DMemRspDataBeSx[31:24] =  CtrlDMemByteEn[3] ? DMemRspData[31:24]:\n                                 CtrlSignExt       ? {8{WrBackData[23]}}: 8'b0;\n//\nassign WrBackData = SelDMemWb ? DMemRspDataBeSx : AluOut;\n\n\nendmodule\n")),(0,i.kt)("p",null,"In that stage we decide what data to write back to the register file. The data can be the result of the ALU operation or the data that was read from the data memory. The data that is read from the data memory is sign extended according to the instruction type."))}p.isMDXComponent=!0}}]);