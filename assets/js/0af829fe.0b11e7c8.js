"use strict";(self.webpackChunkmy_docs=self.webpackChunkmy_docs||[]).push([[3486],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>Q});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var d=n.createContext({}),u=function(e){var t=n.useContext(d),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},c=function(e){var t=u(e.components);return n.createElement(d.Provider,{value:t},e.children)},s="mdxType",H={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,d=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),s=u(a),m=r,Q=s["".concat(d,".").concat(m)]||s[m]||H[m]||i;return a?n.createElement(Q,o(o({ref:t},c),{},{components:a})):n.createElement(Q,o({ref:t},c))}));function Q(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=m;var l={};for(var d in t)hasOwnProperty.call(t,d)&&(l[d]=t[d]);l.originalType=e,l[s]="string"==typeof e?e:r,o[1]=l;for(var u=2;u<i;u++)o[u]=a[u];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},5098:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>H,frontMatter:()=>i,metadata:()=>l,toc:()=>u});var n=a(7462),r=(a(7294),a(3905));const i={},o="exe",l={unversionedId:"rvc/common/exe",id:"rvc/common/exe",title:"exe",description:"execution stage",source:"@site/docs/rvc/common/exe.md",sourceDirName:"rvc/common",slug:"/rvc/common/exe",permalink:"/fpga_mafia_wiki/docs/rvc/common/exe",draft:!1,editUrl:"https://github.com/FPGA-MAFIA/fpga_mafia_wiki/tree/main/docs/rvc/common/exe.md",tags:[],version:"current",frontMatter:{},sidebar:"RISCV_Cores",previous:{title:"rf",permalink:"/fpga_mafia_wiki/docs/rvc/common/rf"},next:{title:"mem_acs",permalink:"/fpga_mafia_wiki/docs/rvc/common/mem_acs"}},d={},u=[{value:"execution stage",id:"execution-stage",level:2},{value:"instantiation of execution module in mini_core.sv",id:"instantiation-of-execution-module-in-mini_coresv",level:3},{value:"Execution module mini_core_exe.sv",id:"execution-module-mini_core_exesv",level:3},{value:"Code explanation - Data Hazard Detection Unit",id:"code-explanation---data-hazard-detection-unit",level:3},{value:"mini_core_exe abstract data hazard detection diagram",id:"mini_core_exe-abstract-data-hazard-detection-diagram",level:3},{value:"Code explanation - Forwarding Unit",id:"code-explanation---forwarding-unit",level:3},{value:"mini_core_exe abstract execution diagram",id:"mini_core_exe-abstract-execution-diagram",level:3}],c={toc:u},s="wrapper";function H(e){let{components:t,...i}=e;return(0,r.kt)(s,(0,n.Z)({},c,i,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"exe"},"exe"),(0,r.kt)("h2",{id:"execution-stage"},"execution stage"),(0,r.kt)("p",null,"The goals of that stage are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("ol",{parentName:"li"},(0,r.kt)("li",{parentName:"ol"},"Use the Imm/Registers to compute:",(0,r.kt)("br",{parentName:"li"}),"a. data to write back to register.",(0,r.kt)("br",{parentName:"li"}),"b. Calculate address for load/store",(0,r.kt)("br",{parentName:"li"}),"c. Calculate branch/jump target.  "))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("ol",{parentName:"li",start:2},(0,r.kt)("li",{parentName:"ol"},"Check branch condition."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("ol",{parentName:"li",start:3},(0,r.kt)("li",{parentName:"ol"},"Data hazard detection and forwarding. "))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"This stage is called Q102H."))),(0,r.kt)("h3",{id:"instantiation-of-execution-module-in-mini_coresv"},"instantiation of execution module in mini_core.sv"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"mini_core_exe mini_core_exe (\n  .Clock               (Clock              ), //  input \n  .Rst                 (Rst                ), //  input \n  // Input Control Signals\n  .Ctrl                (CtrlExe            ), //  input \n  .ReadyQ103H          (ReadyQ103H         ), //  input\n  // Output Control Signals\n  .BranchCondMetQ102H  (BranchCondMetQ102H ), //  output\n  // Input Data path\n  //Q102H\n  .PreRegRdData1Q102H  (RegRdData1Q102H ), //  input \n  .PreRegRdData2Q102H  (RegRdData2Q102H ), //  input \n  .PcQ102H             (PcQ102H            ), //  input \n  .ImmediateQ102H      (ImmediateQ102H     ), //  input \n  //Q104H\n  .RegWrDataQ104H      (RegWrDataQ104H     ), //  input \n  // output data path\n  .AluOutQ102H         (AluOutQ102H        ), //  output\n  .AluOutQ103H         (AluOutQ103H        ), //  output\n  .PcPlus4Q103H        (PcPlus4Q103H       ), //  output\n  .DMemWrDataQ103H     (DMemWrDataQ103H    )  //  output\n);\n")),(0,r.kt)("h3",{id:"execution-module-mini_core_exesv"},"Execution module mini_core_exe.sv"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"//-----------------------------------------------------------------------------\n// Title            : \n// Project          : mafia_asap\n//-----------------------------------------------------------------------------\n// File             : \n// Original Author  : Amichai Ben-David\n// Code Owner       : \n// Adviser          : Amichai Ben-David\n// Created          : 7/2023\n//-----------------------------------------------------------------------------\n\n`include \"macros.sv\"\n\nmodule mini_core_exe\nimport common_pkg::*;\n(\n    input  logic        Clock,\n    input  logic        Rst,\n    //===================\n    // Input Control Signals\n    //===================\n    input  var t_ctrl_exe   Ctrl,\n    input  logic        ReadyQ103H,\n    //===================\n    // Output Control Signals\n    //===================\n    output logic       BranchCondMetQ102H ,\n    //===================\n    // Input Data path\n    //===================\n    //Q102H\n    input logic [31:0]  PreRegRdData1Q102H,\n    input logic [31:0]  PreRegRdData2Q102H,\n    input logic [31:0]  PcQ102H,\n    input logic [31:0]  ImmediateQ102H,\n    //Q104H\n    input logic [31:0]  RegWrDataQ104H, // used for forwarding\n    //===================\n    // output data path\n    //===================\n    output logic [31:0] AluOutQ102H,\n    output logic [31:0] AluOutQ103H,\n    output logic [31:0] PcPlus4Q103H,\n    output logic [31:0] DMemWrDataQ103H\n);\n\nlogic        Hazard1Data1Q102H, Hazard2Data1Q102H, Hazard1Data2Q102H, Hazard2Data2Q102H;\nlogic [31:0] AluIn1Q102H, AluIn2Q102H;\nlogic [4:0]  ShamtQ102H;\nlogic [31:0] RegRdData1Q102H, RegRdData2Q102H;\n//////////////////////////////////////////////////////////////////////////////////////////////////\n//    _____  __     __   _____   _        ______          ____    __    ___    ___    _    _ \n//   / ____| \\ \\   / /  / ____| | |      |  ____|        / __ \\  /_ |  / _ \\  |__ \\  | |  | |\n//  | |       \\ \\_/ /  | |      | |      | |__          | |  | |  | | | | | |    ) | | |__| |\n//  | |        \\   /   | |      | |      |  __|         | |  | |  | | | | | |   / /  |  __  |\n//  | |____     | |    | |____  | |____  | |____        | |__| |  | | | |_| |  / /_  | |  | |\n//   \\_____|    |_|     \\_____| |______| |______|        \\___\\_\\  |_|  \\___/  |____| |_|  |_|\n//                                                                                           \n//////////////////////////////////////////////////////////////////////////////////////////////////\n// Execute\n// -----------------\n// 1. Use the Imm/Registers to compute:\n//      a) data to write back to register.\n//      b) Calculate address for load/store\n//      c) Calculate branch/jump target.\n// 2. Check branch condition.\n//////////////////////////////////////////////////////////////////////////////////////////////////\n// Hazard Detection\nassign Hazard1Data1Q102H = (Ctrl.RegSrc1Q102H == Ctrl.RegDstQ103H) && (Ctrl.RegWrEnQ103H) && (Ctrl.RegSrc1Q102H != 5'b0);\nassign Hazard2Data1Q102H = (Ctrl.RegSrc1Q102H == Ctrl.RegDstQ104H) && (Ctrl.RegWrEnQ104H) && (Ctrl.RegSrc1Q102H != 5'b0);\nassign Hazard1Data2Q102H = (Ctrl.RegSrc2Q102H == Ctrl.RegDstQ103H) && (Ctrl.RegWrEnQ103H) && (Ctrl.RegSrc2Q102H != 5'b0);\nassign Hazard2Data2Q102H = (Ctrl.RegSrc2Q102H == Ctrl.RegDstQ104H) && (Ctrl.RegWrEnQ104H) && (Ctrl.RegSrc2Q102H != 5'b0);\n// Forwarding unite\nassign RegRdData1Q102H = Hazard1Data1Q102H ? AluOutQ103H       : // Rd 102 After Wr 103\n                         Hazard2Data1Q102H ? RegWrDataQ104H    : // Rd 102 After Wr 104\n                                             PreRegRdData1Q102H; // Common Case - No Hazard\n\nassign RegRdData2Q102H = Hazard1Data2Q102H ? AluOutQ103H       : // Rd 102 After Wr 103\n                         Hazard2Data2Q102H ? RegWrDataQ104H    : // Rd 102 After Wr 104 \n                                             PreRegRdData2Q102H; // Common Case - No Hazard\n\n// End Take care to data hazard\nassign AluIn1Q102H = Ctrl.SelAluPcQ102H  ? PcQ102H          : RegRdData1Q102H;\nassign AluIn2Q102H = Ctrl.SelAluImmQ102H ? ImmediateQ102H   : RegRdData2Q102H;\n\nalways_comb begin : alu_logic\n  ShamtQ102H      = AluIn2Q102H[4:0];\n  unique casez (Ctrl.AluOpQ102H) \n    // Adder\n    ADD     : AluOutQ102H = AluIn1Q102H +   AluIn2Q102H;                            // ADD/LW/SW/AUIOC/JAL/JALR/BRANCH/\n    SUB     : AluOutQ102H = AluIn1Q102H + (~AluIn2Q102H) + 1'b1;                    // SUB\n    SLT     : AluOutQ102H = {31'b0, ($signed(AluIn1Q102H) < $signed(AluIn2Q102H))}; // SLT\n    SLTU    : AluOutQ102H = {31'b0 , AluIn1Q102H < AluIn2Q102H};                    // SLTU\n    // Shifter\n    SLL     : AluOutQ102H = AluIn1Q102H << ShamtQ102H;                              // SLL\n    SRL     : AluOutQ102H = AluIn1Q102H >> ShamtQ102H;                              // SRL\n    SRA     : AluOutQ102H = $signed(AluIn1Q102H) >>> ShamtQ102H;                    // SRA\n    // Bit wise operations\n    XOR     : AluOutQ102H = AluIn1Q102H ^ AluIn2Q102H;                              // XOR\n    OR      : AluOutQ102H = AluIn1Q102H | AluIn2Q102H;                              // OR\n    AND     : AluOutQ102H = AluIn1Q102H & AluIn2Q102H;                              // AND\n    default : AluOutQ102H = AluIn1Q102H + AluIn2Q102H;\n  endcase\n  if (Ctrl.LuiQ102H) AluOutQ102H = AluIn2Q102H;                                     // LUI\nend\n\nalways_comb begin : branch_comp\n  // Check branch condition\n  unique casez ({Ctrl.BranchOpQ102H})\n    BEQ     : BranchCondMetQ102H =  (RegRdData1Q102H == RegRdData2Q102H);                  // BEQ\n    BNE     : BranchCondMetQ102H = !(RegRdData1Q102H == RegRdData2Q102H);                  // BNE\n    BLT     : BranchCondMetQ102H =  ($signed(RegRdData1Q102H) < $signed(RegRdData2Q102H)); // BLT\n    BGE     : BranchCondMetQ102H = !($signed(RegRdData1Q102H) < $signed(RegRdData2Q102H)); // BGE\n    BLTU    : BranchCondMetQ102H =  (RegRdData1Q102H < RegRdData2Q102H);                   // BLTU\n    BGEU    : BranchCondMetQ102H = !(RegRdData1Q102H < RegRdData2Q102H);                   // BGEU\n    default : BranchCondMetQ102H = 1'b0;\n  endcase\nend\n\n// Q102H to Q103H Flip Flops\n`MAFIA_EN_DFF(DMemWrDataQ103H     , RegRdData2Q102H     , Clock, ReadyQ103H)\n`MAFIA_EN_DFF(AluOutQ103H         , AluOutQ102H         , Clock, ReadyQ103H)\n`MAFIA_EN_DFF(PcPlus4Q103H        , (PcQ102H+32'd4)     , Clock, ReadyQ103H)\n\nendmodule\n")),(0,r.kt)("h3",{id:"code-explanation---data-hazard-detection-unit"},"Code explanation - Data Hazard Detection Unit"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"// Hazard Detection\nassign Hazard1Data1Q102H = (Ctrl.RegSrc1Q102H == Ctrl.RegDstQ103H) && (Ctrl.RegWrEnQ103H) && (Ctrl.RegSrc1Q102H != 5'b0);   \nassign Hazard2Data1Q102H = (Ctrl.RegSrc1Q102H == Ctrl.RegDstQ104H) && (Ctrl.RegWrEnQ104H) && (Ctrl.RegSrc1Q102H != 5'b0);   \nassign Hazard1Data2Q102H = (Ctrl.RegSrc2Q102H == Ctrl.RegDstQ103H) && (Ctrl.RegWrEnQ103H) && (Ctrl.RegSrc2Q102H != 5'b0);\nassign Hazard2Data2Q102H = (Ctrl.RegSrc2Q102H == Ctrl.RegDstQ104H) && (Ctrl.RegWrEnQ104H) && (Ctrl.RegSrc2Q102H != 5'b0);\n")),(0,r.kt)("p",null,"Lets take a look on some hazards that can occur in our pipeline:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"add x1, x2, x3 # Q103H\nadd x4, x1, x5 # Q102H\n")),(0,r.kt)("p",null,"In the second line we need ",(0,r.kt)("inlineCode",{parentName:"p"},"x1")," register value that is not ready yet because the instruction in Q103H is not finished yet."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"add x1, x2, x3 # Q104H\nadd x4, x5, x6 # Q103H\nadd x7, x1, x8 # Q102H\n")),(0,r.kt)("p",null,"In the third line we need ",(0,r.kt)("inlineCode",{parentName:"p"},"x1")," register value that is not ready yet because the instruction in Q104H is not finished yet."),(0,r.kt)("p",null,"another interesting examples:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"add x1, x2, x3 # Q103H\nsw  x1, 0(x2)  # Q102H\n")),(0,r.kt)("h3",{id:"mini_core_exe-abstract-data-hazard-detection-diagram"},"mini_core_exe abstract data hazard detection diagram"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"---------------------------------------------------------------------------------------------------------------------------------------")),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"hazard_detection_Q102H",src:a(6377).Z,width:"856",height:"418"})),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"---------------------------------------------------------------------------------------------------------------------------------------")),(0,r.kt)("h3",{id:"code-explanation---forwarding-unit"},"Code explanation - Forwarding Unit"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"// Forwarding unite\nassign RegRdData1Q102H = Hazard1Data1Q102H ? AluOutQ103H       : // Rd 102 After Wr 103\n                         Hazard2Data1Q102H ? RegWrDataQ104H    : // Rd 102 After Wr 104\n                                             PreRegRdData1Q102H; // Common Case - No Hazard\n\nassign RegRdData2Q102H = Hazard1Data2Q102H ? AluOutQ103H       : // Rd 102 After Wr 103\n                         Hazard2Data2Q102H ? RegWrDataQ104H    : // Rd 102 After Wr 104 \n                                             PreRegRdData2Q102H; // Common Case - No Hazard\n\n// End Take care to data hazard\nassign AluIn1Q102H = Ctrl.SelAluPcQ102H  ? PcQ102H          : RegRdData1Q102H;\nassign AluIn2Q102H = Ctrl.SelAluImmQ102H ? ImmediateQ102H   : RegRdData2Q102H;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"RegRdData1Q102H - This is the data that is going to be used as the first operand in the ALU. We need to take care of data hazard. If the data is not ready yet, we need to forward it from the write back stage or from memory stage.   ")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If Hazard1Data1Q102H equals to 1, it means that the register read data 1 (rs1) at decode stage (Q102H) is the same as the register write data (rd) at memory stage (Q103H) meaning that the read data is not ready yet. In this case, we forward data from Q103H stage directly to Q102H stage. The data calculated in the previous clock cycle and stored in AluOutQ103H.   ")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If Hazard2Data1Q102H equals to 1, it means that the register read data 2 (rs2) at decode stage (Q102H) is the same as the register write data (rd) at write back stage (Q104H) meaning that the read data is not ready yet. In this case, we forward data from Q104H stage directly to Q102H stage. ")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"In case when there is no hazard, we just take the data from the register file (PreRegRdData1Q102H).")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"AluIn1Q102H - This is the data that is going to be used as the first operand in the ALU. If SelAluPcQ102H equals to 1, it means that the ALU should use the PC as the first operand for instructions that adds immediate to Pc. If SelAluPcQ102H equals to 0, it means that the ALU should use the data from the register file as the first operand.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"AluIn2Q102H - This is the data that is going to be used as the second operand in the ALU. If SelAluImmQ102H equals to 1, it means that the ALU should use the immediate as the second operand. If SelAluImmQ102H equals to 0, it means that the ALU should use the data from the register file as the second operand.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"We assume that other parts of the code are relatively easy to understand. You may use the figure below to understand the flow of data in the execution stage."))),(0,r.kt)("h3",{id:"mini_core_exe-abstract-execution-diagram"},"mini_core_exe abstract execution diagram"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"---------------------------------------------------------------------------------------------------------------------------------------"),"\n",(0,r.kt)("img",{alt:"exe",src:a(6860).Z,width:"1069",height:"659"}),"\n",(0,r.kt)("strong",{parentName:"p"},"---------------------------------------------------------------------------------------------------------------------------------------")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Please note that the above implementation behaves correctly but the real hardware implementation can be changed depending on the synthesis tool you use.")))}H.isMDXComponent=!0},6860:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/exe-111cd3e3ce6c11a533f1c198105eec0a.jpg"},6377:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/hazard_detection_Q102H-e90ecb4f729ce199dd9b45bc74dd94c1.jpg"}}]);