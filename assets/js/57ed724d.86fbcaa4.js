"use strict";(self.webpackChunkmy_docs=self.webpackChunkmy_docs||[]).push([[4964],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var r=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},u=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=c(n),d=i,h=p["".concat(s,".").concat(d)]||p[d]||m[d]||o;return n?r.createElement(h,a(a({ref:t},u),{},{components:n})):r.createElement(h,a({ref:t},u))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,a=new Array(o);a[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[p]="string"==typeof e?e:i,a[1]=l;for(var c=2;c<o;c++)a[c]=n[c];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},8500:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>a,default:()=>m,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var r=n(7462),i=(n(7294),n(3905));const o={},a=void 0,l={unversionedId:"rvc/big_core/exceptions",id:"rvc/big_core/exceptions",title:"exceptions",description:"Introduction",source:"@site/docs/rvc/big_core/exceptions.md",sourceDirName:"rvc/big_core",slug:"/rvc/big_core/exceptions",permalink:"/fpga_mafia_wiki/docs/rvc/big_core/exceptions",draft:!1,editUrl:"https://github.com/FPGA-MAFIA/fpga_mafia_wiki/tree/main/docs/rvc/big_core/exceptions.md",tags:[],version:"current",frontMatter:{},sidebar:"RISCV_Cores",previous:{title:"pmon",permalink:"/fpga_mafia_wiki/docs/rvc/big_core/pmon"},next:{title:"intro",permalink:"/fpga_mafia_wiki/docs/rvc/mini_core/intro"}},s={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Synchronous Exceptions",id:"synchronous-exceptions",level:3},{value:"Asynchronous Exceptions (Interrupts)",id:"asynchronous-exceptions-interrupts",level:3},{value:"Exceptions In our RISC-V Core",id:"exceptions-in-our-risc-v-core",level:2},{value:"Illegal Instruction Exception (trap)",id:"illegal-instruction-exception-trap",level:2},{value:"Causes of illegal instructions",id:"causes-of-illegal-instructions",level:3},{value:"Cases in our core",id:"cases-in-our-core",level:3},{value:"Illegal Instruction Generation",id:"illegal-instruction-generation",level:3},{value:"Illegal Instruction Mechanism",id:"illegal-instruction-mechanism",level:3},{value:"crt0.s_boot_trap.s file",id:"crt0s_boot_traps-file",level:3},{value:"Interrupt_handler.h",id:"interrupt_handlerh",level:3},{value:"Timer interrupt exception",id:"timer-interrupt-exception",level:2},{value:"Timer interrupt flow",id:"timer-interrupt-flow",level:3}],u={toc:c},p="wrapper";function m(e){let{components:t,...n}=e;return(0,i.kt)(p,(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"Synchronous and asynchronous exceptions are fundamental concepts in computer architecture, distinguishing between exceptions caused directly by the execution of instructions and those resulting from external events or conditions. Here's a breakdown of examples for both types:"),(0,i.kt)("h3",{id:"synchronous-exceptions"},"Synchronous Exceptions"),(0,i.kt)("p",null,"Synchronous exceptions, also known as traps, are directly caused by the execution of the current instruction sequence. They include:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Instruction Address Misaligned: Occurs when an instruction is fetched from a non-aligned address that does not conform to the architecture's alignment requirements."),(0,i.kt)("li",{parentName:"ol"},"Load Address Misaligned: Similar to the instruction address misalignment, but occurs during a load operation from a non-aligned memory address."),(0,i.kt)("li",{parentName:"ol"},"Store/AMO Address Misaligned: Occurs during a store or atomic memory operation to a non-aligned memory address."),(0,i.kt)("li",{parentName:"ol"},"Page Fault: Occurs when accessing a page that is not currently mapped in the memory management unit (MMU), requiring a page table walk or indicating a protection violation."),(0,i.kt)("li",{parentName:"ol"},"Floating Point Exception: Arises when a floating-point operation results in an undefined or unrepresentable result, such as division by zero, overflow, or underflow."),(0,i.kt)("li",{parentName:"ol"},"System Call: A deliberate exception triggered by software to request a service from the operating system's kernel.")),(0,i.kt)("h3",{id:"asynchronous-exceptions-interrupts"},"Asynchronous Exceptions (Interrupts)"),(0,i.kt)("p",null,"Asynchronous exceptions, or interrupts, occur independently of the instruction stream currently being executed. They are typically triggered by external events. Examples include:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"External Interrupts: Generated by devices outside the CPU, such as network cards, keyboards, or other peripherals, signaling that they require attention."),(0,i.kt)("li",{parentName:"ol"},"Timer Interrupts: Generated by a timer within the processor, useful for operating system schedulers to implement multitasking by periodically interrupting the current process."),(0,i.kt)("li",{parentName:"ol"},"Inter-Processor Interrupts (IPIs): Used in multi-processor systems where one processor needs to interrupt or signal another processor, often for task scheduling or synchronization purposes.\nBoth synchronous and asynchronous exceptions are integral to the operation of modern computing systems, enabling efficient and controlled management of resources, error handling, and interaction between hardware and software components.")),(0,i.kt)("h2",{id:"exceptions-in-our-risc-v-core"},"Exceptions In our RISC-V Core"),(0,i.kt)("h2",{id:"illegal-instruction-exception-trap"},"Illegal Instruction Exception (trap)"),(0,i.kt)("p",null,"Illegal instruction is a synchronous exception because its origin comes from the software flow. "),(0,i.kt)("h3",{id:"causes-of-illegal-instructions"},"Causes of illegal instructions"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Un familiar instruction that belongs to a specific RISCV extension that not supported bt the core."),(0,i.kt)("li",{parentName:"ul"},"Hw errors while fetching the instruction from the memory."),(0,i.kt)("li",{parentName:"ul"},"Custom instructions that not supported by RISCV spec (In most of the cases the compiler will not compile that)."),(0,i.kt)("li",{parentName:"ul"},"Compiler errors (very rare but possible).")),(0,i.kt)("h3",{id:"cases-in-our-core"},"Cases in our core"),(0,i.kt)("p",null,"For more details, please refer to ",(0,i.kt)("inlineCode",{parentName:"p"},"/source/big_core/illegal_instruction.vh")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Some of the ",(0,i.kt)("inlineCode",{parentName:"li"},"Funct7")," fields in R-type instructions do not zero"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Funct3")," do not match the instruction. For example we try to execute S-type instruction and ",(0,i.kt)("inlineCode",{parentName:"li"},"Funct3  = 111"),"."),(0,i.kt)("li",{parentName:"ul"},"Un recognized OpCode that not supported by the core or not allowed by the spec.")),(0,i.kt)("h3",{id:"illegal-instruction-generation"},"Illegal Instruction Generation"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"We use the test ",(0,i.kt)("inlineCode",{parentName:"li"},"/verif/big_core/alive_illegal.c"),"."),(0,i.kt)("li",{parentName:"ul"},"We try to create an instruction with illegal ",(0,i.kt)("inlineCode",{parentName:"li"},"FUCT7"),", we generate ",(0,i.kt)("inlineCode",{parentName:"li"},"slli")," with funct7 = 0x7f instead of 0x0")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'   // This instruction is trying to generate slli instruction with illegal FUNCT7.\n    asm(".word 0xfff79793" : /* outputs / : / inputs / : / clobbers */);\n')),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"This is a code snippet from the ",(0,i.kt)("inlineCode",{parentName:"li"},"elf.txt")," file")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"  1660: fd010113            addi    sp,sp,-48\n        .\n        .\n        .\n    1674:   00200793            li  a5,2\n    1678:   fef42423            sw  a5,-24(s0)\n    167c:   fff79793            0xfff79793\n    1680:   fec42703            lw  a4,-20(s0)\n        .\n        .\n        .\n    16b0:   00008067            ret\n")),(0,i.kt)("h3",{id:"illegal-instruction-mechanism"},"Illegal Instruction Mechanism"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Detection if illegal instruction inside the controller :\n",(0,i.kt)("inlineCode",{parentName:"li"},"assign IllegalInstructionQ101H = (PreIllegalInstructionQ101H) && ! (flushQ102H || flushQ103H);"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"In case of illegal instruction and flush, we do not start the the interrupt routine because the instruction will be flushed anyway."),(0,i.kt)("li",{parentName:"ul"},"When the illegal instruction is a part of the instruction flow than we erase that instruction by inserting ",(0,i.kt)("inlineCode",{parentName:"li"},"NOP")," and jumps to the interrupt routine.")),(0,i.kt)("ol",{start:2},(0,i.kt)("li",{parentName:"ol"},"Csr update\nOnce we decide to take the exception we start to update and read csr's. T")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"We update the cause of the exception by modifying the ",(0,i.kt)("inlineCode",{parentName:"li"},"csr_mcause")," csr by assign the ",(0,i.kt)("inlineCode",{parentName:"li"},"32'h00000002"),"."),(0,i.kt)("li",{parentName:"ul"},"Update ",(0,i.kt)("inlineCode",{parentName:"li"},"csr_mepc")," with the return value PC of the illegal instruction. We will use it as return address from the interrupt routine."),(0,i.kt)("li",{parentName:"ul"},"Update ",(0,i.kt)("inlineCode",{parentName:"li"},"csr_mtval")," with the illegal instruction machine code. In our case it will be ",(0,i.kt)("inlineCode",{parentName:"li"},"fff79793")),(0,i.kt)("li",{parentName:"ul"},"Set the ",(0,i.kt)("inlineCode",{parentName:"li"},"CSR_MSTATUS[MIE]")," to the current value of ",(0,i.kt)("inlineCode",{parentName:"li"},"CSR_MSTATUS[MIE]")," to store the previous machine interrupt enable mode."),(0,i.kt)("li",{parentName:"ul"},"Disable ",(0,i.kt)("inlineCode",{parentName:"li"},"CSR_MSTATUS[MIE]")," when taking an exception to avoid nested interrupts.   ")),(0,i.kt)("ol",{start:3},(0,i.kt)("li",{parentName:"ol"},"Jumps to Interrupt routine")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Store the values of the registers"),(0,i.kt)("li",{parentName:"ul"},"Perform the routine\nJump to ",(0,i.kt)("inlineCode",{parentName:"li"},"csr_mtvec")," value that keeps the address pf the routine.")),(0,i.kt)("ol",{start:4},(0,i.kt)("li",{parentName:"ol"},"Return from interrupt routine")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Restore the registers"),(0,i.kt)("li",{parentName:"ul"},"update ",(0,i.kt)("inlineCode",{parentName:"li"},"CSR_MSTATUS[MIE]")," with ",(0,i.kt)("inlineCode",{parentName:"li"},"CSR_MSTATUS[MIE]"),". ")),(0,i.kt)("h3",{id:"crt0s_boot_traps-file"},"crt0.s_boot_trap.s file"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"csr_init:\n  li t0, 0x100      # Load the immediate value 0x100 of trap handler address\n  csrw mtvec, t0    # Write the value in t0 to the mtvec CSR\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The address of the interrupt routine is ",(0,i.kt)("inlineCode",{parentName:"li"},"0x100")),(0,i.kt)("li",{parentName:"ul"},"Inside that file we store and restore the registers before jumping to the routine inside ",(0,i.kt)("inlineCode",{parentName:"li"},"interrupt_handler.h"),".\nPlease see ",(0,i.kt)("inlineCode",{parentName:"li"},"/app/crt0/crt0_boot_trap.S")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"/app/defines/interrupt_handler.h"))),(0,i.kt)("h3",{id:"interrupt_handlerh"},"Interrupt_handler.h"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},' if ((mcause & 0xFFF) == ILLEGAL_INSTRUCTION_EXCEPTION) { \n        csr_mepc = read_mepc();\n        csr_mtval = read_mtval();\n        rvc_printf("ILGL INST\\n");\n        rvc_printf("MEPC:");\n        rvc_print_unsigned_int_hex(csr_mepc);\n        rvc_printf("\\n");\n        rvc_printf("MTVAL:");\n        rvc_print_unsigned_int_hex(csr_mtval);\n        rvc_printf("\\n");\n       }\n')),(0,i.kt)("h2",{id:"timer-interrupt-exception"},"Timer interrupt exception"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"We use internal timer to generate the interrupt. The timer interrupt mechanism compared between ",(0,i.kt)("inlineCode",{parentName:"li"},"csr_custom_mtime")," to ",(0,i.kt)("inlineCode",{parentName:"li"},"csr_custom_mtimecmp")," (will be explained soon)"),(0,i.kt)("li",{parentName:"ul"},"One of the tests we use is `bubblesort_with_timer.c' to test the timer interrupt")),(0,i.kt)("h3",{id:"timer-interrupt-flow"},"Timer interrupt flow"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"By default we disable timer interrupts. The reason for that is to avoid from any exceptions while booting the system like we do in crt0.s file")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"csr_init:\n  li t0, 0x100      # Load the immediate value 0x100 of trap handler address\n  csrw mtvec, t0    # Write the value in t0 to the mtvec CSR\n\n  # Enable software and external interrupts. Set meie and msie to 1 and mtie to 0 as default values\n  li t0, 0x808\n  csrw  mie, t0     \n  \n  # Enable interrupts. Set MIE and MPIE bit to 1 and 0 respectively in mstatus register.\n  li t0, 0x8\n  csrw  mstatus, t0 \n  \n  # update custom csr at address 0xBC0 that serves as mtimecmp register\n  li t0, 0x00000500\n  csrw 0xBC0, t0  \n")),(0,i.kt)("p",null,"  The above code is a part of csr initialization in the crt0.s file. We disable timer interrupts by clear ",(0,i.kt)("inlineCode",{parentName:"p"},"MTIP")," bit. We allow other interrupts to be taken by setting mie csr bits and mstatus appropriate bits. We set ",(0,i.kt)("inlineCode",{parentName:"p"},"csr_custom_mtimecmp")," to 0x500.\n2. Inside the csr module once ",(0,i.kt)("inlineCode",{parentName:"p"},"csr_custom_mtime >= csr_custom_mtimecmp"),", we put the timer interrupt interrupt in pending mode   "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"next_csr.csr_mip[CSR_MIP_MTIP]  = (csr.csr_custom_mtime >= csr.csr_custom_mtimecmp);\n")),(0,i.kt)("ol",{start:3},(0,i.kt)("li",{parentName:"ol"},"From naive perspective, the timer interrupt can ocurred only when the following conditions are met:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"assign TimerInterruptEnable =  csr.csr_mip[CSR_MIP_MTIP]          && // 1) mtime >= mtimecmp : MTIP - Machine Timer Interrupt Pending\n                               csr.csr_mstatus[CSR_MSTATUS_MIE]   && // 2) in mstatus register MIE bit is set\n                               csr.csr_mie[CSR_MIE_MTIE];            // 3) in mie register MTIE bit is set\n")),(0,i.kt)("ol",{start:4},(0,i.kt)("li",{parentName:"ol"},"When ",(0,i.kt)("inlineCode",{parentName:"li"},"TimerInterruptEnable = 1"),' than the we let the controller to decide whether to take the interrupt or not. We do that cause we do not want to take that exception while the controller has an "Invalid Instruction". The condition that effects if the exception will be taken or not are inside the controller.')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"assign TimerInterruptTakenQ101H = (TimerInterruptEnable) & (PreValidInstQ101H) & !(JumpOrBranch) & !(IllegalInstructionQ101H);\n")),(0,i.kt)("ol",{start:5},(0,i.kt)("li",{parentName:"ol"},"Once the Timer interrupt begins we do the following:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"update mcause"),(0,i.kt)("li",{parentName:"ul"},"update mepc with the return address"),(0,i.kt)("li",{parentName:"ul"},"set the CSR_MSTATUS","[MPIE]"," to the current value of CSR_MSTATUS","[MIE]"),(0,i.kt)("li",{parentName:"ul"},"disable CSR_MSTATUS","[MIE]"," when taking an exception to avoid nested interrupts")),(0,i.kt)("ol",{start:6},(0,i.kt)("li",{parentName:"ol"},"We store the registers and jumps to interrupt handler. At the end we update ",(0,i.kt)("inlineCode",{parentName:"li"},"csr_custom_mtimecmp")," with new value ")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"    if (mcause == MACHINE_TIMER_INTERRUPT) {\n        \n        //Run the mtime interrupt handler routine\n        mtime_routine_handler();\n        \n        unsigned int csr_custom_mtime    = read_custom_mtime();\n        unsigned int csr_custom_mtimecmp = read_custom_mtimecmp();\n        \n        csr_custom_mtimecmp = csr_custom_mtime + TIMER_INTERRUPT_INTERVAL; \n        write_custom_mtimecmp(csr_custom_mtimecmp);\n\n\n       }\n")),(0,i.kt)("ol",{start:7},(0,i.kt)("li",{parentName:"ol"},"Restore the registers and return to the original program"),(0,i.kt)("li",{parentName:"ol"},"next_csr.csr_mstatus","[CSR_MSTATUS_MIE]"," = csr.csr_mstatus","[CSR_MSTATUS_MPIE]",";")))}m.isMDXComponent=!0}}]);