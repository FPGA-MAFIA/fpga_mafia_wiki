"use strict";(self.webpackChunkmy_docs=self.webpackChunkmy_docs||[]).push([[6977],{3905:(e,n,r)=>{r.d(n,{Zo:()=>d,kt:()=>u});var t=r(7294);function i(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function a(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,t)}return r}function o(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?a(Object(r),!0).forEach((function(n){i(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function c(e,n){if(null==e)return{};var r,t,i=function(e,n){if(null==e)return{};var r,t,i={},a=Object.keys(e);for(t=0;t<a.length;t++)r=a[t],n.indexOf(r)>=0||(i[r]=e[r]);return i}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(t=0;t<a.length;t++)r=a[t],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var s=t.createContext({}),l=function(e){var n=t.useContext(s),r=n;return e&&(r="function"==typeof e?e(n):o(o({},n),e)),r},d=function(e){var n=l(e.components);return t.createElement(s.Provider,{value:n},e.children)},f="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},m=t.forwardRef((function(e,n){var r=e.components,i=e.mdxType,a=e.originalType,s=e.parentName,d=c(e,["components","mdxType","originalType","parentName"]),f=l(r),m=i,u=f["".concat(s,".").concat(m)]||f[m]||p[m]||a;return r?t.createElement(u,o(o({ref:n},d),{},{components:r})):t.createElement(u,o({ref:n},d))}));function u(e,n){var r=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var a=r.length,o=new Array(a);o[0]=m;var c={};for(var s in n)hasOwnProperty.call(n,s)&&(c[s]=n[s]);c.originalType=e,c[f]="string"==typeof e?e:i,o[1]=c;for(var l=2;l<a;l++)o[l]=r[l];return t.createElement.apply(null,o)}return t.createElement.apply(null,r)}m.displayName="MDXCreateElement"},6358:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>c,toc:()=>l});var t=r(7462),i=(r(7294),r(3905));const a={},o=void 0,c={unversionedId:"rvc/sc_core/macros",id:"rvc/sc_core/macros",title:"macros",description:"macros.sv file",source:"@site/docs/rvc/sc_core/macros.md",sourceDirName:"rvc/sc_core",slug:"/rvc/sc_core/macros",permalink:"/fpga_mafia_wiki/docs/rvc/sc_core/macros",draft:!1,editUrl:"https://github.com/FPGA-MAFIA/fpga_mafia_wiki/tree/main/docs/rvc/sc_core/macros.md",tags:[],version:"current",frontMatter:{},sidebar:"RISCV_Cores",previous:{title:"intro",permalink:"/fpga_mafia_wiki/docs/rvc/sc_core/intro"},next:{title:"sc_core_pkg",permalink:"/fpga_mafia_wiki/docs/rvc/sc_core/sc_core_pkg"}},s={},l=[{value:"macros.sv file",id:"macrossv-file",level:3}],d={toc:l},f="wrapper";function p(e){let{components:n,...r}=e;return(0,i.kt)(f,(0,t.Z)({},d,r,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h3",{id:"macrossv-file"},"macros.sv file"),(0,i.kt)("p",null," This file has some macros that we use in our design. ",(0,i.kt)("strong",{parentName:"p"},"That file is common to some other Mafia RTL cores and that the reason its relatively long"),". We will explain only the relevant macros for the ",(0,i.kt)("inlineCode",{parentName:"p"},"sc_core")," cpu.   "),(0,i.kt)("p",null," This file is located in ",(0,i.kt)("inlineCode",{parentName:"p"},"/common/macros.sv")," folder    "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"//-----------------------------------------------------------------------------\n// Title            : simple core  design\n// Project          : simple_core\n//-----------------------------------------------------------------------------\n// File             : core\n// Original Author  : Amichai Ben-David\n// Code Owner       : \n// Created          : 9/2022\n//-----------------------------------------------------------------------------\n// Description :\n// This file will be a single cycle core implemenation of the RV32I RISCV specification\n// Fetch, Decode, Exe, Mem, Write_Back\n//-----------------------------------------------------------------------------\n\n`ifndef MACROS_VS\n`define MACROS_VS\n\n`define  MAFIA_DFF(q,i,clk)       \\\n         always_ff @(posedge clk) \\\n            q<=i;\n\n`define  MAFIA_EN_DFF(q,i,clk,en) \\\n         always_ff @(posedge clk) \\\n            if(en) q<=i;\n\n`define  MAFIA_RST_DFF(q,i,clk,rst)    \\\n         always_ff @(posedge clk) begin\\\n            if (rst) q <='0;           \\\n            else     q <= i;           \\\n         end\n\n`define  MAFIA_RST_VAL_DFF(q,i,clk,rst,val) \\\n         always_ff @(posedge clk) begin     \\\n            if (rst) q <=val;               \\\n            else     q <= i;                \\\n         end\n\n\n`define  MAFIA_EN_RST_DFF(q,i,clk,en,rst)\\\n         always_ff @(posedge clk)        \\\n            if (rst)    q <='0;          \\\n            else if(en) q <= i;\n\n// a async reset val en flop used for special cases\n`define MAFIA_EN_ASYNC_RST_VAL_DFF(q,i,clk,en,rst,val) \\\n         always_ff @(posedge clk or posedge rst) begin \\\n            if      (rst) q <= val;                    \\\n            else if (en)  q <= i;                      \\\n         end\n\n`define MAFIA_METAFLOP(out,i,clk)     \\\n   logic next``out;                   \\\n        `MAFIA_DFF(next``out, i,clk)  \\\n        `MAFIA_DFF(out,next``out,clk)\n\n\n\n`define MAFIA_MUXOR(winner, candidates, select)     \\\nalways_comb begin                                   \\\n    winner = '0;                                    \\\n    for(int i =0; i < $bits(select); i++) begin     \\\n        winner = select[i] ? candidates[i] : winner;\\\n    end                                             \\\nend\n\n`define  MAFIA_FIND_FIRST(first , candidates )              \\\n    always_comb begin                                       \\\n        first = '0;                                         \\\n        for(int i =0; i < $bits(candidates); i++) begin     \\\n            first[i] = candidates[i] & (!(|first));         \\\n        end                                                 \\\n    end                                        \n\n`define  MAFIA_ENCODER(encoded ,valid, decoded )      \\\n   always_comb begin                                  \\\n        encoded = '0 ;                                \\\n        valid   = |decoded;                           \\\n        for (int i = 0 ; i <$bits(decoded) ;i++) begin\\\n        if (decoded[i])                               \\\n            encoded = i ;                             \\\n    end                                               \\\n    end \n\n`define  MAFIA_DECODER(decoded , encoded, valid )\\\n    always_comb begin                            \\\n      decoded = '0 ;                             \\\n      if(valid) decoded[encoded] = 1'b1 ;        \\\n   end \n\n`define MAFIA_ASSERT(name, expr, en, msg)                      \\\n   always @(posedge clk) begin                                 \\\n      if (en && expr) begin                                    \\\n         $error($sformatf(\"[MAFIA_ASSERT] %s: %s\", name, msg));\\\n      end                                                      \\\n   end          \n\n\n`define MAFIA_BINARY_TO_GRAY(gray,binary)  \\\n   gray = binary ^ (binary >> 1);   \n      \n\n`endif //MACROS_VS\n\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Because we use ",(0,i.kt)("inlineCode",{parentName:"li"},"sc_core,")," than the only sequential element we use is for ",(0,i.kt)("inlineCode",{parentName:"li"},"PC")," register and Register file, the macro that used for Pc is:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"`define  MAFIA_RST_DFF(q,i,clk,rst)    \\\n         always_ff @(posedge clk) begin\\\n            if (rst) q <='0;           \\\n            else     q <= i;           \\\n         end\n\n")),(0,i.kt)("p",null,"As you can see, this macro is a simple DFF with reset."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The macro that used for writing to Register file is:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"`define  MAFIA_EN_DFF(q,i,clk,en) \\\n         always_ff @(posedge clk) \\\n            if(en) q<=i;\n")),(0,i.kt)("p",null,"As you can see, this macro is a simple DFF with enable."))}p.isMDXComponent=!0}}]);