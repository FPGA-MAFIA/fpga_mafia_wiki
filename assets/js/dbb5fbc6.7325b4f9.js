"use strict";(self.webpackChunkmy_docs=self.webpackChunkmy_docs||[]).push([[3603],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>f});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=r.createContext({}),s=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=s(e.components);return r.createElement(c.Provider,{value:t},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,c=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),m=s(n),d=a,f=m["".concat(c,".").concat(d)]||m[d]||u[d]||i;return n?r.createElement(f,o(o({ref:t},p),{},{components:n})):r.createElement(f,o({ref:t},p))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=d;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l[m]="string"==typeof e?e:a,o[1]=l;for(var s=2;s<i;s++)o[s]=n[s];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9465:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>s});var r=n(7462),a=(n(7294),n(3905));const i={},o=void 0,l={unversionedId:"rvc/big_core/pmon",id:"rvc/big_core/pmon",title:"pmon",description:"Performance Monitor",source:"@site/docs/rvc/big_core/pmon.md",sourceDirName:"rvc/big_core",slug:"/rvc/big_core/pmon",permalink:"/fpga_mafia_wiki/docs/rvc/big_core/pmon",draft:!1,editUrl:"https://github.com/FPGA-MAFIA/fpga_mafia_wiki/tree/main/docs/rvc/big_core/pmon.md",tags:[],version:"current",frontMatter:{},sidebar:"RISCV_Cores",previous:{title:"cr_mem",permalink:"/fpga_mafia_wiki/docs/rvc/big_core/cr_mem"},next:{title:"exceptions",permalink:"/fpga_mafia_wiki/docs/rvc/big_core/exceptions"}},c={},s=[{value:"Performance Monitor",id:"performance-monitor",level:2},{value:"realistic example",id:"realistic-example",level:3},{value:"results explanation",id:"results-explanation",level:3}],p={toc:s},m="wrapper";function u(e){let{components:t,...n}=e;return(0,a.kt)(m,(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"performance-monitor"},"Performance Monitor"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Performance monitoring typically involves mechanisms to observe and analyze the behavior of the processor to identify performance bottlenecks, optimize code, and improve overall system performance.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"One of the most important features of the performance monitoring is the ability to count the number of instructions executed relatively to the number of clock cycles. This is useful for measuring the efficiency of the processor and the code running on it.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"We are going to measure two metrics:"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"CPI (Cycles Per Instruction) - the average number of clock cycles per instruction."),(0,a.kt)("li",{parentName:"ul"},"IPC (Instructions Per Cycle) - the average number of instructions per clock cycle. IPC is the inverse of CPI."))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"To do that we are going to use two csr counters:"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"instret")," - counts the number of instructions retired(executed completely). "),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"cycle")," - counts the number of clock cycles. "),(0,a.kt)("li",{parentName:"ul"},"Those Csr's are read only. They sample the machine mode csr's ",(0,a.kt)("inlineCode",{parentName:"li"},"mcycle")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"minstret"),". ")))),(0,a.kt)("p",null,"Those hard wired counters have a size of 32 bits. Its important to say that RV32 spec allows us to extend their size to 64 bits by using two more counters: ",(0,a.kt)("inlineCode",{parentName:"p"},"instreth")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"cycleh"),". "),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"In our design, we name ",(0,a.kt)("inlineCode",{parentName:"p"},"cycle")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"cycleh")," as ",(0,a.kt)("inlineCode",{parentName:"p"},"CSR_CYCLE_LOW")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"CSR_CYCLE_HIGH")," respectively.",(0,a.kt)("br",{parentName:"p"}),"\n","The same goes for ",(0,a.kt)("inlineCode",{parentName:"p"},"instret")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"instreth")," which are named ",(0,a.kt)("inlineCode",{parentName:"p"},"CSR_INSTRET_LOW")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"CSR_INSTRET_HIGH")," respectively. ")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"The address of ",(0,a.kt)("inlineCode",{parentName:"p"},"CSR_CYCLE_LOW")," is 0xC00 and the address of ",(0,a.kt)("inlineCode",{parentName:"p"},"CSR_CYCLE_HIGH")," is 0xC80. The address of ",(0,a.kt)("inlineCode",{parentName:"p"},"CSR_INSTRET_LOW")," is 0xC02 and the address of ",(0,a.kt)("inlineCode",{parentName:"p"},"CSR_INSTRET_HIGH")," is 0xC82.",(0,a.kt)("sup",{parentName:"p",id:"fnref-1"},(0,a.kt)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1")),".")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"The retired instructions counter (",(0,a.kt)("inlineCode",{parentName:"p"},"instret"),") is incremented by one every time an instruction is valid at the last stage of the pipeline(Q105H). The invalid instructions are caused by flushes, stalls and core freezes.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"After we calculate the number of valid instructions and clock cycles, we can calculate the CPI and IPC. The CPI is calculated by dividing the number of clock cycles by the number of instructions. The IPC is calculated by dividing the number of instructions by the number of clock cycles."))),(0,a.kt)("h3",{id:"realistic-example"},"realistic example"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The task that calculates the CPI and IPC is located at the ",(0,a.kt)("inlineCode",{parentName:"li"},"verif/core_rrv/tb")," folder",(0,a.kt)("sup",{parentName:"li",id:"fnref-2"},(0,a.kt)("a",{parentName:"sup",href:"#fn-2",className:"footnote-ref"},"2"))," "),(0,a.kt)("li",{parentName:"ul"},"We run the following test named ",(0,a.kt)("inlineCode",{parentName:"li"},"alive.c")," on the core_rrv with 6 pipeline stages:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"int sum(int x, int y){\n    return x + y;\n}\n\nint main(){\n    int x = 1;\n    int y = 2;\n  \n    int z = sum(x, y); \n    return 0;\n}\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The summary report is:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"===========================================\nPMON tracker for alive test\nMonitoring IPC and CPI\n==========================================\n\nSummary report\n---------------------\nNumber of cycles: 79\nNumber of valid instructions: 68\nIPC(instruction per cycles) =  0.861\nIPC[%] =  86.076\nCPI(cycles per instruction) =  1.162\n\n")),(0,a.kt)("h3",{id:"results-explanation"},"results explanation"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"it takes 79 clock cycles to execute the test."),(0,a.kt)("li",{parentName:"ul"},"68 valid instructions were executed. The invalid instructions are caused by flushes, stalls and core freezes."),(0,a.kt)("li",{parentName:"ul"},"the IPC is 0.861 which means that on average 0.861 instructions were executed per clock cycle.")),(0,a.kt)("p",null,(0,a.kt)("sup",{parentName:"p",id:"fnref-1"},(0,a.kt)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1"))," The addresses of all the csr's we use in our design located at ",(0,a.kt)("inlineCode",{parentName:"p"},"/source/big_core/big_core_pkg.vh")," file",(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("sup",{parentName:"p",id:"fnref-2"},(0,a.kt)("a",{parentName:"sup",href:"#fn-2",className:"footnote-ref"},"2"))," Because of constant improvements the name of the core may change but it always will belong to one of the big_cores"))}u.isMDXComponent=!0}}]);