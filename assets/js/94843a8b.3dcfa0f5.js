"use strict";(self.webpackChunkmy_docs=self.webpackChunkmy_docs||[]).push([[5061],{3905:(e,t,r)=>{r.d(t,{Zo:()=>_,kt:()=>m});var i=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function n(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,i)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?n(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):n(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function c(e,t){if(null==e)return{};var r,i,a=function(e,t){if(null==e)return{};var r,i,a={},n=Object.keys(e);for(i=0;i<n.length;i++)r=n[i],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(i=0;i<n.length;i++)r=n[i],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var l=i.createContext({}),s=function(e){var t=i.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},_=function(e){var t=s(e.components);return i.createElement(l.Provider,{value:t},e.children)},f="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},p=i.forwardRef((function(e,t){var r=e.components,a=e.mdxType,n=e.originalType,l=e.parentName,_=c(e,["components","mdxType","originalType","parentName"]),f=s(r),p=a,m=f["".concat(l,".").concat(p)]||f[p]||d[p]||n;return r?i.createElement(m,o(o({ref:t},_),{},{components:r})):i.createElement(m,o({ref:t},_))}));function m(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var n=r.length,o=new Array(n);o[0]=p;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c[f]="string"==typeof e?e:a,o[1]=c;for(var s=2;s<n;s++)o[s]=r[s];return i.createElement.apply(null,o)}return i.createElement.apply(null,r)}p.displayName="MDXCreateElement"},3533:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>n,metadata:()=>c,toc:()=>s});var i=r(7462),a=(r(7294),r(3905));const n={},o=void 0,c={unversionedId:"fabric/verification/verification_fabric",id:"fabric/verification/verification_fabric",title:"verification_fabric",description:"Strategy",source:"@site/docs/fabric/verification/verification_fabric.md",sourceDirName:"fabric/verification",slug:"/fabric/verification/verification_fabric",permalink:"/fpga_mafia_wiki/docs/fabric/verification/verification_fabric",draft:!1,editUrl:"https://github.com/FPGA-MAFIA/fpga_mafia_wiki/tree/main/docs/fabric/verification/verification_fabric.md",tags:[],version:"current",frontMatter:{},sidebar:"Fabric",previous:{title:"Fabric Verification Intro",permalink:"/fpga_mafia_wiki/docs/fabric/verification/verification_intro"},next:{title:"verification_fifo_arb",permalink:"/fpga_mafia_wiki/docs/fabric/verification/verification_fifo_arb"}},l={},s=[{value:"Strategy",id:"strategy",level:2},{value:"Code",id:"code",level:3},{value:"fabric_tb",id:"fabric_tb",level:2},{value:"fabric_mini_cores_tb",id:"fabric_mini_cores_tb",level:2}],_={toc:s},f="wrapper";function d(e){let{components:t,...r}=e;return(0,a.kt)(f,(0,i.Z)({},_,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"strategy"},"Strategy"),(0,a.kt)("p",null,"In order to create a good env for the fabric we seperated the fabric into two conceptual components, the first one is the traffic, this part only checks if the data is moving as expected inside the fabric.\nthe second part will be a mini_cores_fabric which include also the mini_cores, so the fabric_mini_cores_tb is an extension of the fabric_tb."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"we also have trackers that it is a log that including all the transactions and the time of the transaction sample.")),(0,a.kt)("h3",{id:"code"},"Code"),(0,a.kt)("h2",{id:"fabric_tb"},"fabric_tb"),(0,a.kt)("p",null,"The fabric_tb is created from 3 main parts. "),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Interface - the interface is where we connect from the software to the hardware, we are not using UVM so everything is a bit different then normal. the fabric is a 3x3 mini_core_tile that created using generate inside the fabric. This fact make it very difficult to get a signal in a generic way like signal","[col][row]"," because of the generate. so we created those signals (i.e. interface) using generate.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-systemverilog"},"genvar row, col;\ngenerate\n  for (col = 1; col <= V_COL; col = col + 1) begin : gen_col\n    for (row = 1; row <= V_ROW; row = row + 1) begin : gen_row\n    // fabric to if \n      assign fabric.col[col].row[row].mini_core_tile_ins.mini_core_top.mini_mem_wrap.C2F_ReqValidQ103H = valid_tile[col][row]; // input to req_fifo \n      assign fabric.col[col].row[row].mini_core_tile_ins.mini_core_top.mini_mem_wrap.C2F_ReqQ103H = origin_trans[col][row];     \n    // if to fabric\n      assign origin_trans_fab[col][row] = fabric.col[col].row[row].mini_core_tile_ins.mini_core_top.mini_mem_wrap.C2F_ReqQ103H;   // input_data to req_fifo    \n      assign tile_rsp_trans[col][row] = fabric.col[col].row[row].mini_core_tile_ins.mini_core_top.mini_mem_wrap.F2C_OutFabricQ504H;// input_data to rd_rsp fifo\n      assign valid_tile_rsp[col][row] = fabric.col[col].row[row].mini_core_tile_ins.mini_core_top.mini_mem_wrap.F2C_OutFabricValidQ504H;// valid input_data to rd_rsp fifo\n      assign valid_local[col][row] = fabric.col[col].row[row].mini_core_tile_ins.out_local_req_valid;\n      assign target_trans[col][row] = fabric.col[col].row[row].mini_core_tile_ins.out_local_req;\n      assign requestor_id_ref[col][row] = fabric.col[col].row[row].mini_core_tile_ins.pre_in_local_req.requestor_id;\n      assign tile_ready[col][row] = fabric.col[col].row[row].mini_core_tile_ins.out_local_ready;\n    end\n  end\nendgenerate\n")),(0,a.kt)("p",null,"We created for each signal a 2D array that is connected to its relevant tile."),(0,a.kt)("ol",{start:2},(0,a.kt)("li",{parentName:"ol"},"sequence - the sequence is creating the traffic for the fabric, collect the data from each tile and then actiate a DI checker.")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"traffic - The data is random but it has more fields, we randomize the source tile and the target tile while making sure that it is not the same tile. then we are randomize the opcode if it is WR or RD. we can read only after write.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"data collection - the data collectors are created like this:"))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-systemverilog"},"static t_tile_trans_v monitor_source_trans [V_ROW:1] [V_COL:1] [$];\n")),(0,a.kt)("p",null,"this is a V_ROWxV_COL queue array from t_tile_trans type. each element is collecting the data for a specific tile, in this case as a source tile."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-systemverilog"},"task automatic fabric_get_source_from_tile();\nt_tile_trans_v [V_COL:1][V_ROW:1] temp_trans_req;\nt_tile_trans_v [V_COL:1][V_ROW:1] temp_trans_rsp;\n  for(int i = 1; i<= V_COL; i++) begin\n    for(int j = 1; j<= V_ROW; j++) begin\n      automatic int col = i;\n      automatic int row = j;\n      fork forever begin\n        t_tile_id source_id;\n        wait(valid_tile[col][row] == 1'b1);\n        source_id[7:4] = col;\n        source_id[3:0] = row;\n        #0;\n        temp_trans_req[col][row].trans.data                  = origin_trans_fab[col][row].data;\n        temp_trans_req[col][row].trans.opcode                = origin_trans_fab[col][row].opcode;\n        temp_trans_req[col][row].trans.address               = origin_trans_fab[col][row].address;\n        temp_trans_req[col][row].trans.next_tile_fifo_arb_id = NULL_CARDINAL;\n        temp_trans_req[col][row].trans.requestor_id = '0;\n        temp_trans_req[col][row].source = source_id;\n        temp_trans_req[col][row].target = origin_trans_fab[col][row].address[31:24];\n        monitor_source_trans[col][row].push_back(temp_trans_req[col][row]);\n        cnt_trans_source = cnt_trans_source + 1;\n        wait(valid_tile[col][row] == 1'b0);\n      end forever begin // RD_RSP\n       t_tile_id source_id_rsp;\n       wait(valid_tile_rsp[col][row] == 1'b1);\n        source_id_rsp[7:4] = col;\n        source_id_rsp[3:0] = row;\n        #0;\n        temp_trans_rsp[col][row].trans.data = '0;\n        temp_trans_rsp[col][row].trans.address = '0;\n        temp_trans_rsp[col][row].trans.opcode  = tile_rsp_trans[col][row].opcode; // input to fifo of RD_RSP in mem_wrap\n        temp_trans_rsp[col][row].trans.requestor_id = '0;\n        temp_trans_rsp[col][row].trans.next_tile_fifo_arb_id = NULL_CARDINAL;\n        temp_trans_rsp[col][row].source = source_id_rsp;\n        temp_trans_rsp[col][row].target = tile_rsp_trans[col][row].address[31:24];\n        monitor_source_trans_rsp[col][row].push_back(temp_trans_rsp[col][row]);\n        cnt_trans_source_rsp = cnt_trans_source_rsp + 1;\n        wait(valid_tile_rsp[col][row] == 1'b0);\n      end\n      join_none\n    end\n  end\n")),(0,a.kt)("p",null,"we have 2 collectors in this env:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"the source collector that collect the data from the source tile it can be a regular data or RD_RSP which is the data that is the data that coming back to the source tile after a read request."),(0,a.kt)("li",{parentName:"ul"},"the target collector is collecting the data that finish its traffic through the fabric.\nThe collectors wait for the relevant signals to be valid and then collect the data into a queue.\nat the end we are activating a DI_checker that checks the data.")),(0,a.kt)("ol",{start:3},(0,a.kt)("li",{parentName:"ol"},"Tests:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-systemverilog"},'task run_fabric_test(input string test);\n  if (test == "fabric_alive") begin\n     `include "fabric_alive.sv"\n  end else if(test == "fabric_all_tiles") begin\n     `include "fabric_all_tiles.sv"\n  end else if(test == "fabric_wr_rd_data") begin\n     `include "fabric_wr_rd_data.sv"\n  end else if(test == "fabric_BP_test") begin\n     `include "fabric_BP_test.sv"\n  end else begin\n    $error(" [ERROR] : test %s not found",test);\n  end\nendtask\n')),(0,a.kt)("p",null,"The 2 main tests are the fabric_all_tiles_test and fabric_BP_test.\nThe fabric_all_tiles_test is activating all tiles in parallel, it ensure that the fabric is reliable when it has all kind of traffic like stress or very low traffic.\nthe fabrc_BP_test is a test that creating a lot of pressure on each tile, we fill all the fifo of all tiles in transactions and we want to see how the fabric is handling the pressure, if he decline new transactions or if after the release of the pressure the fabric is handling it correctley."),(0,a.kt)("h2",{id:"fabric_mini_cores_tb"},"fabric_mini_cores_tb"),(0,a.kt)("p",null,"This tb is taking the fabric_tb that test the fabric traffic alone and adding to it the actual mini_cores.\nin this part we compile a C program that can run on each one of our mini cores. the traffic is verified like before but now we are checking if the program do what it suppose to.\nto do it we created 9 IRAM and DRAM kike this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-systemverilog"},"logic  [7:0] IMem  [V_ROW:1] [V_COL:1]   [I_MEM_SIZE_MINI + I_MEM_OFFSET_MINI - 1 : I_MEM_OFFSET_MINI];\nlogic  [7:0] DMem  [V_ROW:1] [V_COL:1]   [D_MEM_SIZE_MINI + D_MEM_OFFSET_MINI - 1 : D_MEM_OFFSET_MINI];\n")),(0,a.kt)("p",null,"In order to connect them to the design we assigned them by generate like before and then load each one of the core seperatly like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-systemverilog"},'`MAFIA_DFF(IMem, IMem, clk)\ntask load_mem(input int col, input int row);\n    $readmemh({"../../../target/fabric/tests/",test_name,"/gcc_files/inst_mem.sv"} , IMem[col][row]);\n    ...\n')),(0,a.kt)("p",null,"this task is reading the i_mem that created from the linker after compiliation.\nnext we loaded each imem into the relevant mini core like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-systemverilog"},'    ...\n    for(int i = 1; i<= V_COL; i++) begin\n      for(int j = 1; j<= V_ROW; j++) begin\n        automatic int col = i;\n        automatic int row = j;\n        fork begin \n          load_mem(col,row);\n          $display("time is %0t for tile [%0d,%0d]",$time,col,row);\n        end join\n        ...\n        end\n        end\n')),(0,a.kt)("p",null,"In this way we can load for each tile a different program to run in parallel to the other tiles."),(0,a.kt)("h1",{id:"todo---add-dram-explanation-and-add-c-tests-explanation"},"TODO - add DRAM explanation and add c tests explanation."))}d.isMDXComponent=!0}}]);