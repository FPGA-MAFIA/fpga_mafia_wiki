"use strict";(self.webpackChunkmy_docs=self.webpackChunkmy_docs||[]).push([[1418],{3905:(e,n,t)=>{t.d(n,{Zo:()=>g,kt:()=>u});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},s=Object.keys(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var r=a.createContext({}),c=function(e){var n=a.useContext(r),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},g=function(e){var n=c(e.components);return a.createElement(r.Provider,{value:n},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},p=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,s=e.originalType,r=e.parentName,g=o(e,["components","mdxType","originalType","parentName"]),m=c(t),p=i,u=m["".concat(r,".").concat(p)]||m[p]||d[p]||s;return t?a.createElement(u,l(l({ref:n},g),{},{components:t})):a.createElement(u,l({ref:n},g))}));function u(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var s=t.length,l=new Array(s);l[0]=p;var o={};for(var r in n)hasOwnProperty.call(n,r)&&(o[r]=n[r]);o.originalType=e,o[m]="string"==typeof e?e:i,l[1]=o;for(var c=2;c<s;c++)l[c]=t[c];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}p.displayName="MDXCreateElement"},8090:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>d,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var a=t(7462),i=(t(7294),t(3905));const s={},l="Intro to System-Verilog",o={unversionedId:"TFM/verilog/basic_concepts",id:"TFM/verilog/basic_concepts",title:"Intro to System-Verilog",description:"System-Verilog vs Verilog",source:"@site/docs/TFM/verilog/basic_concepts.md",sourceDirName:"TFM/verilog",slug:"/TFM/verilog/basic_concepts",permalink:"/fpga_mafia_wiki/docs/TFM/verilog/basic_concepts",draft:!1,editUrl:"https://github.com/FPGA-MAFIA/fpga_mafia_wiki/tree/main/docs/TFM/verilog/basic_concepts.md",tags:[],version:"current",frontMatter:{},sidebar:"TFM",previous:{title:"Common examples",permalink:"/fpga_mafia_wiki/docs/TFM/verilog/examples"},next:{title:"SystemVerilog Types",permalink:"/fpga_mafia_wiki/docs/TFM/verilog/sv_types"}},r={},c=[{value:"System-Verilog vs Verilog",id:"system-verilog-vs-verilog",level:2},{value:"Assignments: always vs assign",id:"assignments-always-vs-assign",level:2},{value:"Assign",id:"assign",level:3},{value:"Always and SystemVerilog always type",id:"always-and-systemverilog-always-type",level:3},{value:"Sensitivity list",id:"sensitivity-list",level:2}],g={toc:c},m="wrapper";function d(e){let{components:n,...t}=e;return(0,i.kt)(m,(0,a.Z)({},g,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"intro-to-system-verilog"},"Intro to System-Verilog"),(0,i.kt)("h2",{id:"system-verilog-vs-verilog"},"System-Verilog vs Verilog"),(0,i.kt)("p",null,"Verilog and SystemVerilog are both hardware description languages (HDLs) that are used to model, design, and verify digital and mixed-signal systems. Verilog is a standard in the field of electronic design automation (EDA) and is widely used for design and verification of digital circuits. SystemVerilog is an extension of Verilog that includes additional features and capabilities for more advanced design and verification tasks."),(0,i.kt)("h2",{id:"assignments-always-vs-assign"},"Assignments: always vs assign"),(0,i.kt)("p",null,"In SystemVerilog, the assign and always statements are used to specify the behavior of a digital circuit.",(0,i.kt)("br",{parentName:"p"}),"\n","The main difference between these two statements is the type of behavior they can describe."),(0,i.kt)("h3",{id:"assign"},"Assign"),(0,i.kt)("p",null,"The assign statement is used to specify a continuous assignment of a value to a signal. It is triggered whenever the value of any of the signals on the right-hand side of the assignment changes. The assign statement can only describe combinational logic, which has no memory or state.\nWhen using an assign, the left-hand side of the assignment may get a value only once.\nin contrast to always_comb where the left-hand side may be overridden within the always block. (see the always_comb section)\nExamples:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-systemverilog"},"assign c   = a & b; //AND\nassign out = sel ? in1 : in2; //mux\nassign sum = addend_a + addend_b; //add\nassign result = !(|( vec_a ^ vec_b)); //equivalent to (vec_a == vec_b)). achieved by `XOR` bitwise between vec_a^vec_b, then `OR` all the bits, then `NOT` the result.\n")),(0,i.kt)("h3",{id:"always-and-systemverilog-always-type"},"Always and SystemVerilog always type"),(0,i.kt)("p",null,"While in Verilog, always assignments types are determined using the sensitive list & the Block/Non-Blocking assignment,",(0,i.kt)("br",{parentName:"p"}),"\n","in SystemVerilog we use dedicated always_\\<*",">"," blocks to enforce correctness:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"always_comb\nIs equivalent to Verilog ",(0,i.kt)("inlineCode",{parentName:"li"},"always @*"),'\nAny combinatorial error such as "inferred latch" or "combinatorial loop"  will be reported in the compilation.\nUnlike the ',(0,i.kt)("inlineCode",{parentName:"li"},"assign"),", within an ",(0,i.kt)("inlineCode",{parentName:"li"},"always_comb")," the left-hand side signal may get multiple assignments.",(0,i.kt)("br",{parentName:"li"}),"some examples:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-systemverilog"},"//mux\nalways_comb begin\n   if(sel==1'b0)\n      out = in1;\n   else //(sel ==1'b1)\n      out = in2;\nend\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-systemverilog"},"//legal if without else\nalways_comb begin\n   out = '0; //default value\n   if(condition == TRUE)\n      out = other_input; //no latch due to the default value\nend\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-systemverilog"},"//legal multiple assignment to left-hand side within same always_comb\nlogic [31:0] sum_all;\nlogic [31:0] vec[9:0]\nalways_comb begin\nsum_all = '0;\nfor(int i = 0; i<10; i++) begin\n    sum_all= sum_all + vec[i];\nend //for\nend\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-systemverilog"},"//using new assignments in for loop into next loop iteration. \nlogic [31:0] fibb [9:0]\nalways_comb begin\nfibb[0] = 0;\nfibb[1] = 1;\nfor(int i = 2; i<10; i++) begin\n    fibb[i] = fibb[i-1] + fibb[i-2];\nend //for\nend\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'always_latch\nThe always_latch statement is used to describe logic that has a latch-like behavior.\nA common way to create a latch is "if without else". example:')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-SystemVerilog"},"always_latch begin\n  if(en)  out = in;\nend\n")),(0,i.kt)("p",null,'in this logic, the out is a "memory cell". this due to no value is given to ',(0,i.kt)("inlineCode",{parentName:"p"},"out")," if the 'en==0'.\nSo out must \"remember\" its old value. this is done using a latch memory cell."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"always_ff\nIs equivalent to Verilog ",(0,i.kt)("inlineCode",{parentName:"li"},"always @(posedge clk)"),'\nThis will also enforce the correct usage of "Non-Blocking" assignment within the logic')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-SystemVerilog"},"always_ff @(posedge clk) begin\n  if (rst) q <='0;\n    else   q <= in;\nend\n")),(0,i.kt)("p",null,"Note that in the sensitivity list of the always_ff we only have the ",(0,i.kt)("inlineCode",{parentName:"p"},"clk"),".\nThis will make any of the assignments in the block evaluated ",(0,i.kt)("strong",{parentName:"p"},"only"),' on the clock positive edge.\nAn implication of this is the fact that the Reset won\'t have any effect on the flop output without having the Clock toggling.\nAlso known as a "synchronized reset flop"'),(0,i.kt)("h2",{id:"sensitivity-list"},"Sensitivity list"),(0,i.kt)("p",null,"A sensitivity list is a list of signals used to trigger a procedural block of code.\nIn verilog Sensitivity lists are used in every always block to specify the conditions under which the block will be executed.\nVerilog example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"always @(a or b or c) begin\n  d = (a && b) || (c);\nend\n")),(0,i.kt)("p",null,"Note: This coding style is prone to disasters, where you might miss a signal in the sensitivity list and accidentally create a ",(0,i.kt)("inlineCode",{parentName:"p"},"latch"),"\nIn this example, the c is not part of the sensitivity list, which means d may not be evaluated if only c has changed.\nThis will cause the ",(0,i.kt)("inlineCode",{parentName:"p"},"d"),' signal to become a "latch" memory cell so it can remember its last value.'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"always @(a or b) begin\n  d = (a && b) || (c);\nend\n")),(0,i.kt)("p",null,"to simplify, Verilog allows all right-hand side signals to be part of the sensitivity list by using a ",(0,i.kt)("inlineCode",{parentName:"p"},"wild card")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"always @* begin\n  d = (a && b) || (c);\nend\n")),(0,i.kt)("p",null,"In SystemVerilog coding style, the sensitivity list shenanigans are eliminated by simply using an ",(0,i.kt)("inlineCode",{parentName:"p"},"always_comb"),".\nAnd latches are carefully designed only when they are intended by adding the ",(0,i.kt)("inlineCode",{parentName:"p"},"always_latch")," block."),(0,i.kt)("h1",{id:"blocking-vs-non-blocking-assignment"},"Blocking vs Non-Blocking assignment"),(0,i.kt)("p",null,"The main difference between these two types of assignments is how they are executed in relation to the rest of the code in a design.",(0,i.kt)("br",{parentName:"p"}),"\n","Blocking assignments are executed immediately and block the execution of any other statements until the assignment is completed.",(0,i.kt)("br",{parentName:"p"}),"\n","They are denoted by the ",(0,i.kt)("inlineCode",{parentName:"p"},"=")," operator and are commonly used for simple assignments or for modeling combinatorial logic. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-systemverilog"},"always_comb begin\n   x = y;      // blocking assignment\n   z = x + y;  // blocking assignment - z is getting the x evaluation from the previous line\nend\n")),(0,i.kt)("p",null,"On the other hand, non-blocking assignments are executed at the end of a time step and do not block the execution of other statements.",(0,i.kt)("br",{parentName:"p"}),"\n","They are denoted by the ",(0,i.kt)("inlineCode",{parentName:"p"},"<=")," operator and are commonly used for modeling sequential logic or updating registers.",(0,i.kt)("br",{parentName:"p"}),"\n","For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-systemverilog"},"always_ff @(posedge clk) begin\n   x <= y;      // non-blocking assignment\n   z <= x + y;  // non-blocking assignment - z is getting the x evaluation from the **previous clock cycle** and not the previous line.\nend\n")),(0,i.kt)("p",null,"Please note:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Never mix blocking & non-Blocking assignments"),(0,i.kt)("li",{parentName:"ul"},"Use non-Blocking assignments with sequential logic, such as Flops"),(0,i.kt)("li",{parentName:"ul"},"It is recommended to have all sequential logic wrapped in ","`","macros",(0,i.kt)("br",{parentName:"li"}),"this means we can get a design without any visible non-Blocking assignments\nAnd we are very specific about the sequential logic, which has the non-Blocking assignments hidden in the `macros.")))}d.isMDXComponent=!0}}]);