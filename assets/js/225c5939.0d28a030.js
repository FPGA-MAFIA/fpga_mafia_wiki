"use strict";(self.webpackChunkmy_docs=self.webpackChunkmy_docs||[]).push([[2818],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>g});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),p=c(n),m=i,g=p["".concat(s,".").concat(m)]||p[m]||u[m]||r;return n?a.createElement(g,o(o({ref:t},d),{},{components:n})):a.createElement(g,o({ref:t},d))}));function g(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[p]="string"==typeof e?e:i,o[1]=l;for(var c=2;c<r;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},2057:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var a=n(7462),i=(n(7294),n(3905));const r={},o="SystemVerilog Types",l={unversionedId:"TFM/verilog/sv_types",id:"TFM/verilog/sv_types",title:"SystemVerilog Types",description:"reg, wire, logic",source:"@site/docs/TFM/verilog/sv_types.md",sourceDirName:"TFM/verilog",slug:"/TFM/verilog/sv_types",permalink:"/fpga_mafia_wiki/docs/TFM/verilog/sv_types",draft:!1,editUrl:"https://github.com/FPGA-MAFIA/fpga_mafia_wiki/tree/main/docs/TFM/verilog/sv_types.md",tags:[],version:"current",frontMatter:{},sidebar:"TFM",previous:{title:"Intro to System-Verilog",permalink:"/fpga_mafia_wiki/docs/TFM/verilog/basic_concepts"},next:{title:"Multiple dimensional arrays",permalink:"/fpga_mafia_wiki/docs/TFM/verilog/multi_dim_array"}},s={},c=[{value:"reg, wire, logic",id:"reg-wire-logic",level:2},{value:"System-Verilog typedef",id:"system-verilog-typedef",level:2},{value:"Parameter, localparam, Package",id:"parameter-localparam-package",level:2},{value:"Package",id:"package",level:4},{value:"Module",id:"module",level:2},{value:"Function",id:"function",level:2},{value:"Macro",id:"macro",level:2}],d={toc:c},p="wrapper";function u(e){let{components:t,...n}=e;return(0,i.kt)(p,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"systemverilog-types"},"SystemVerilog Types"),(0,i.kt)("h2",{id:"reg-wire-logic"},"reg, wire, logic"),(0,i.kt)("p",null,"The reg and wire data types are used to represent digital signals in a hardware description. The main difference between these two data types is their use and the type of behavior they can describe."),(0,i.kt)("p",null,"The reg data type represents variables that can be assigned a value within a procedural block of code, such as an always block.",(0,i.kt)("br",{parentName:"p"}),"\n","reg variables can be used to describe ",(0,i.kt)("strong",{parentName:"p"},"both")," combinatorial and sequential logic, and they can be assigned a value using blocking(=) and non-blocking (<=) assignments."),(0,i.kt)("p",null,"The wire data type is used to represent signals that are interconnections between modules or between blocks of code within a module. wire signals can be used to describe combinatorial logic, and they cannot be assigned a value within a procedural block of code. Instead, they are driven by continuous assignments (using the assign statement) or by the output of a gate or module."),(0,i.kt)("p",null,'Note: In Verilog, a signal may be driven by combinatorial logic if it\'s a wire or reg. this means there is no "real" difference between the two once we synthesize the block. the only difference is that a reg type ',(0,i.kt)("strong",{parentName:"p"},"can")," (but not necessarily) get a non-blocking assignment (as flop output) or be a latch output. which ",(0,i.kt)("inlineCode",{parentName:"p"},"wire")," type can't.\nBut what determines if ",(0,i.kt)("inlineCode",{parentName:"p"},"reg")," is a memory cell is the context where it's used!"),(0,i.kt)("p",null,"In SystemVerilog, the ",(0,i.kt)("inlineCode",{parentName:"p"},"logic")," data type is a multi-purpose data type that can represent digital signals in a hardware description.",(0,i.kt)("br",{parentName:"p"}),"\n","It is a more flexible and powerful data type than the ",(0,i.kt)("inlineCode",{parentName:"p"},"wire")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"reg")," types in Verilog,\nUsing ",(0,i.kt)("inlineCode",{parentName:"p"},"logic")," instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"wire")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"reg")," in SystemVerilog designs is highly recommended."),(0,i.kt)("p",null,"Here are some reasons why logic is generally considered to be better than wire and reg in SystemVerilog:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Type compatibility: logic is more type-compatible with other data types than wire and reg. For example, logic can be used as an element type in arrays, as a member of a structs, used both in ",(0,i.kt)("inlineCode",{parentName:"li"},"assign")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"always")," blocks, used for module interface.\nGenerally, whenever you want a logical signal in your circuit, the ",(0,i.kt)("inlineCode",{parentName:"li"},"logic")," type will due. "),(0,i.kt)("li",{parentName:"ol"},"Type inference: logic supports type inference, which means that it can be assigned a value from any type that can be implicitly converted to logic. This allows for more flexible and concise code, as it is not necessary to explicitly specify the type of every variable."),(0,i.kt)("li",{parentName:"ol"},"Mixed-signal modeling: logic has four subtypes (bit, logic, tri, and triand) that can represent different digital signals, such as single-bit signals, multi-bit vectors, tri-state signals, and high-impedance signals. This makes it easier to model mixed-signal systems that include both digital and analog components.")),(0,i.kt)("p",null,"Overall, logic is a more powerful and flexible data type than wire and reg in SystemVerilog. Using logic instead of wire and reg in SystemVerilog designs is generally recommended."),(0,i.kt)("h2",{id:"system-verilog-typedef"},"System-Verilog typedef"),(0,i.kt)("p",null,"the typedef keyword defines a new type alias for an existing type. It allows you to create a new name for an existing type, making your code more readable and easier to maintain.",(0,i.kt)("br",{parentName:"p"}),"\n","Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-SystemVerilog"},"typedef logic [31:0] t_address;\ntypedef logic [3:0] t_tq_id;\n")),(0,i.kt)("p",null,"typedef can also be used to create type aliases for user-defined types, such as structures or unions.",(0,i.kt)("br",{parentName:"p"}),"\n","For example:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"enum")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-SystemVerilog"},"typedef enum logic [1:0] {\n        RED         = 2'b00,\n        YELLOW      = 2'b01,\n        GREEN       = 2'b10,\n        RED_YELLOW  = 2'b11\n} t_state;\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"struct")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-systemverilog"},"typedef struct packed {\n    logic         valid;\n    t_opcode      opcode;\n    t_address     address;\n    t_data        data;\n} t_req ;\n")),(0,i.kt)("p",null,"accessing a struct field is state forward.",(0,i.kt)("br",{parentName:"p"}),"\n","Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-SystemVerilog"},"t_req request;\nt_address  new_address;\nassign new_address = request.address;// accessing the address field from the request struct\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"union")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-systemverilog"},"typedef struct packed {\n    logic         valid;  // 1 bit\n    logic [5:0]   date;   // 6 bit\n    logic [2:0]   opcode; // 3 bit\n} t_a_type ;              // 10 bit in total\ntypedef struct packed {\n    logic         valid;  // 1 bit\n    logic [4:0]   address;// 5 bit\n    logic [1:0]   opcode; // 2 bit\n    logic [1:0]   rsvd;   // 2 bit\n} t_b_type ;              // 10 bit in total\n\ntypedef union {\n  t_a_type a; // 10 bit\n  t_b_type b; // 10 bit\n} t_union;    // the union is still 10 bit!\n")),(0,i.kt)("p",null,"Using the union, we can access any field using the union type:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-systemverilog"},"t_union physical_io;\nt_a_type a_bus;\nt_b_type b_bus;\n// assign 2 different types on to the same physical port:\nassign physical_io = sel ? a_bus : b_bus;\n// Then we can access any field on the physical_io:\nassign address = physical_io.b.address[4:0];\nassign data    = physical_io.a.data[5:0];\n")),(0,i.kt)("h2",{id:"parameter-localparam-package"},"Parameter, localparam, Package"),(0,i.kt)("p",null,"In SystemVerilog, both localparam and parameter are used to define constants, but there are some key differences between the two:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"localparam is used to define constants within a module or an interface, and it cannot be overridden by any other module or interface. It can only be accessed within the same module or interface where it is defined. The value of a localparam is determined during the elaboration phase of the simulation and cannot be changed during runtime."),(0,i.kt)("li",{parentName:"ul"},"parameter is also used to define constants within a module or an interface, but a higher-level module or interface can override it. It can be accessed by any module that instantiates the module where it is defined. The value of a parameter can be determined during both the elaboration and runtime phases of the simulation.\nExample for passing a parameter in module instance:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-systemverilog"},"module top;\n// instantiate the module\nmy_module #(.WIDTH(8), .DEPTH(16)) \nmy_instance (\n .clk(clk),\n .rst(rst),\n .in_req(in_req),\n .out_rsp(out_rsp)\n)\n//module content\n...\n\nendmodule\n\nmodule my_module (\n    parameter WIDTH = 8, //default value\n    parameter DEPTH = 16 //default value \n)(\n    input logic clk,\n    input logic rst,\n    input t_req  in_req,\n    output t_req out_rsp\n);\n    // module contents\n    ...\nendmodule\n")),(0,i.kt)("p",null,"In summary, localparam are more restrictive and cannot be overridden. In contrast, parameters are more flexible and can be overridden."),(0,i.kt)("h4",{id:"package"},"Package"),(0,i.kt)("p",null,"A SystemVerilog package is a collection of data types, functions, and other constructs that can be used to organize and reuse design elements.\nA package allows you to encapsulate related functionality and make it available to other parts of the design without duplicating code. It also provides a way to organize and manage the design hierarchy by grouping related elements together. Packages can be used to define interfaces, data types, and classes that can be shared across multiple design modules, making it easier to reuse and maintain the design. They also provide a way to hide implementation details, while exposing a clear and consistent interface to other parts of the design.\nExample:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-systemverilog"},"package my_pkg;\nparameter NUM_ELEMENTS  = 6;\n...\ntypedef struct packed {\n    logic [1:0]            A;\n    logic [NUM_ELEMENTS-1:0] B;    \n} t_my_struct;\n... \netc.\n")),(0,i.kt)("p",null,"importing a package:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-systemverilog"},'// package declaration\npackage my_package;\n    // package contents (data types, structs, enums, parameters, functions, etc.)\nendpackage\n\n// module declaration\nmodule my_module;\n    import my_package::*;\n(\n    input   logic   clk,\n    input   logic   rst,\n    input   t_req   req, // "t_req" type is a typedef struct from the "my_package"\n    output  t_rsp   rsp  // "t_rsp" type is a typedef struct from the "my_package"\n);\nalways_comb begin\n    for (int i = 0; i < ITERATIONS; i++) begin //ITERATIONS is a parameter declared in "my_package"\n        // do something\n    end\nend\nassign t_rsp.header  = ...; // the t_rsp struct fields are described in "my_package"\nassign t_rsp.data    = ...;\nassign t_rsp.address = ...;\nassign t_rsp.opcode  = ...;\n\nendmodule\n\n')),(0,i.kt)("h1",{id:"module-function-macro"},"Module, Function, Macro"),(0,i.kt)("p",null,"In system verilog, there are multiple ways to define a block of code that can be reused.",(0,i.kt)("br",{parentName:"p"}),"\n","Note: The content of a module, function or macro must be synthesizable to be used in RTL.",(0,i.kt)("br",{parentName:"p"}),"\n","For verification, it is possible to use non-synthesizable code, and there are other options such as task, class, etc.  "),(0,i.kt)("h2",{id:"module"},"Module"),(0,i.kt)("p",null,"A module is a collection of code that can be instantiated in other modules.\nUsing a module is the most common way encapsulate a logical block.\nModule can be reused in multiple places in the design.\nExample:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-systemverilog"},"module my_module (\n    input logic clk,\n    input logic rst,\n    input t_req  in_req,\n    output t_req out_rsp\n);\n    // module contents\n    ...\nendmodule\n")),(0,i.kt)("h2",{id:"function"},"Function"),(0,i.kt)("p",null,"A function is a code that can be called from other modules.\nUsing a function is a good way to encapsulate a block of code that can be reused.\nIs systemverilog, function are best to use in asynchronous logic, where the output is combinatorial logic of the inputs (without clock or reset)."),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-systemverilog"},"function logic [3:0] some_function(input logic [3:0] in);\n    // function contents\n    ...\nendfunction\n")),(0,i.kt)("h2",{id:"macro"},"Macro"),(0,i.kt)("p",null,"A macro is a code that can be called from other modules.\nMacros are parsed by the pre-compilation phase of the compiler, and treated by the compiler as a text replacement. This means that the macro is replaced by the text that is defined in the macro, and the compiler does not see the macro as a hierarchical block.\nMacros are great for synchronous logic such non-blocking assignments -> DFF and all its variants.\nThis will allow us to call common logic in a single line, and not have to write it multiple times. without introducing a module or function hierarchy.\nExample:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-systemverilog"},"`define  DFF(q,i,clk)             \\\n         always_ff @(posedge clk) \\\n            q<=i;\n")))}u.isMDXComponent=!0}}]);