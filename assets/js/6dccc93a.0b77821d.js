"use strict";(self.webpackChunkmy_docs=self.webpackChunkmy_docs||[]).push([[2310],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=c(n),m=r,h=d["".concat(s,".").concat(m)]||d[m]||u[m]||l;return n?a.createElement(h,i(i({ref:t},p),{},{components:n})):a.createElement(h,i({ref:t},p))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,i=new Array(l);i[0]=m;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[d]="string"==typeof e?e:r,i[1]=o;for(var c=2;c<l;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},1811:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>l,metadata:()=>o,toc:()=>c});var a=n(7462),r=(n(7294),n(3905));const l={},i="ctrl",o={unversionedId:"rvc/common/ctrl",id:"rvc/common/ctrl",title:"ctrl",description:"mini_core controller",source:"@site/docs/rvc/common/ctrl.md",sourceDirName:"rvc/common",slug:"/rvc/common/ctrl",permalink:"/fpga_mafia_wiki/docs/rvc/common/ctrl",draft:!1,editUrl:"https://github.com/FPGA-MAFIA/fpga_mafia_wiki/tree/main/docs/rvc/common/ctrl.md",tags:[],version:"current",frontMatter:{},sidebar:"RISCV_Cores",previous:{title:"wb",permalink:"/fpga_mafia_wiki/docs/rvc/common/wb"},next:{title:"intro",permalink:"/fpga_mafia_wiki/docs/rvc/big_core/intro"}},s={},c=[{value:"mini_core controller",id:"mini_core-controller",level:2},{value:"Instantiation of mini_core controller in mini_core.sv",id:"instantiation-of-mini_core-controller-in-mini_coresv",level:3},{value:"Signal description",id:"signal-description",level:3},{value:"mini_core controller module mini_core_ctrl.sv",id:"mini_core-controller-module-mini_core_ctrlsv",level:3},{value:"Load Hazard",id:"load-hazard",level:3},{value:"Lets take a more detailed look",id:"lets-take-a-more-detailed-look",level:3},{value:"Control Hazard",id:"control-hazard",level:3},{value:"Back pressure",id:"back-pressure",level:3},{value:"Control signals goes threw the pipeline",id:"control-signals-goes-threw-the-pipeline",level:3},{value:"ebreak detection",id:"ebreak-detection",level:3},{value:"note",id:"note",level:3}],p={toc:c},d="wrapper";function u(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"ctrl"},"ctrl"),(0,r.kt)("h2",{id:"mini_core-controller"},"mini_core controller"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"After you understood the mini_core architecture, you can start to understand the mini_core controller.   ")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The mini_core controller is the main module of the mini_core implemented as a combination logic.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The controller is a part of Q101H stage of the pipeline.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The controller goals are:",(0,r.kt)("br",{parentName:"p"}),"\n","1) Create all control signals, enable signals and select signal for each stage of the pipeline in the data path.",(0,r.kt)("br",{parentName:"p"}),"\n","2) Responsible for the control hazard and Load hazard detection.",(0,r.kt)("br",{parentName:"p"}),"\n","3) Get the instruction from I_MEM and use the decoder to set the Ctrl Bits.",(0,r.kt)("br",{parentName:"p"}),"\n","4) Construct the Immediate types.",(0,r.kt)("br",{parentName:"p"}),"\n","5) Use the rs1 & rs2 (RegSrc) to read the Register file data.",(0,r.kt)("br",{parentName:"p"}),"\n","6) Flush pipe line in case of branch or jump.   "))),(0,r.kt)("h3",{id:"instantiation-of-mini_core-controller-in-mini_coresv"},"Instantiation of mini_core controller in mini_core.sv"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'mini_core_ctrl mini_core_ctrl (\n  .Rst                  (Rst    ), //input\n  .Clock                (Clock  ), //input\n  // input instruction \n  .PreInstructionQ101H  (PreInstructionQ101H), //input\n  .PcQ101H              (PcQ101H), // output logic [31:0] PcQ101H\n  // input feedback from data path\n  .BranchCondMetQ102H   (BranchCondMetQ102H), //input\n  .DMemReady            (DMemReady), //input\n  // ready signals for "back-pressure" - use as the enable for the pipe stage sample\n  .ReadyQ100H           (ReadyQ100H), //  output \n  .ReadyQ101H           (ReadyQ101H), //  output \n  .ReadyQ102H           (ReadyQ102H), //  output \n  .ReadyQ103H           (ReadyQ103H), //  output \n  .ReadyQ104H           (ReadyQ104H), //  output \n  // output ctrl signals\n  .CtrlIf               (CtrlIf             ), //output\n  .CtrlRf               (CtrlRf             ), //output\n  .CtrlExe              (CtrlExe            ), //output\n  .CtrlMem              (CtrlMem            ), //output\n  .CtrlWb               (CtrlWb             ), //output\n  // output data path signals\n  .ImmediateQ101H       (ImmediateQ101H     ) //output\n);\n')),(0,r.kt)("h3",{id:"signal-description"},"Signal description"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"preInstructionQ101H:")," That signal is an input to mini_core controller. It is the instruction that comes from instruction memory."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"BranchCondMetQ102H:")," That signal comes from Q102H stage and indicates if the branch condition is met. ",(0,r.kt)("a",{parentName:"li",href:"/fpga_mafia_wiki/docs/rvc/common/exe"},"Click here")," to learn more."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"CtrIf, CtrlRf, CtrlExe, CtrlMem, CtrlWb:")," These signals are output from mini_core controller. They are the control signals for each stage of the pipeline. Those signals are a part of ",(0,r.kt)("inlineCode",{parentName:"li"},"typedef struct packed named t_ctrl_if, t_ctrl_rf, t_ctrl_exe, t_ctrl_mem, t_ctrl_wb")," (see mini_core_pkg.vh file) variables. We saw all of them in the previous sections.")),(0,r.kt)("h3",{id:"mini_core-controller-module-mini_core_ctrlsv"},"mini_core controller module mini_core_ctrl.sv"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The full code of the mini_core controller located at ",(0,r.kt)("inlineCode",{parentName:"li"},"/src/mini_core/mini_core_ctrl.sv"),".")),(0,r.kt)("h3",{id:"load-hazard"},"Load Hazard"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A load hazard is not the same as a data hazard we talked before in the execution stage. A data hazard happens when the data we need is in the pipeline but not in the right place yet. On the other hand, a load hazard occurs when we need data right now, but it hasn't been figured out yet. In these situations, we have to stall (stop) the pipeline and wait until the data becomes available.   "),(0,r.kt)("li",{parentName:"ul"},"Lets have a look at the following instruction that causes load hazard")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"lw x1, imm(x2)  #Q102H\nadd x3, x1, x4  #Q101H\n")),(0,r.kt)("p",null,"In the second instruction we need the data from the first instruction, but the data is not ready yet. We have to stall the pipeline and wait until the data becomes available."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The following code shows how we detect load hazard in the mini_core controller is detected.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"assign LoadHzrdDetectQ101H       = Rst ? 1'b0 : \n                                 ((PreRegSrc1Q101H == CtrlQ102H.RegDst) && (CtrlQ102H.Opcode == LOAD)) ? 1'b1:\n                                 ((PreRegSrc2Q101H == CtrlQ102H.RegDst) && (CtrlQ102H.Opcode == LOAD)) ? 1'b1:\n                                                                                                         1'b0;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Note that load hazard detection is done in Q101H stage. We compare the destination register of the previous instruction located in Q102H stage with the source registers of the current instruction located Q101H stage. If the previous instruction is a load instruction and the destination register of the previous instruction is the same as the source register of the current instruction, then we have a load hazard. In this case we have to stall the pipeline and wait until the data becomes available.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"To solve that problem we do the following things:",(0,r.kt)("br",{parentName:"p"}),"\n","1) Stall Pc in Q100H stage",(0,r.kt)("br",{parentName:"p"}),"\n","2) Disenable IF/ID register  "))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"assign ReadyQ101H = (!CoreFreeze) && !(LoadHzrdDetectQ101H); //\nassign ReadyQ100H = (!CoreFreeze) && ReadyQ101H;//\n")),(0,r.kt)("p",null,"3) Inserting bubble (NOP)",(0,r.kt)("sup",{parentName:"p",id:"fnref-1"},(0,r.kt)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1"))," into Q101H stage. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"assign InstructionQ101H = flushQ102H          ? NOP :\n                         flushQ103H          ? NOP :\n                         LoadHzrdDetectQ101H ? NOP : \n                                               PreInstructionQ101H;\nassign PreValidInstQ101H = flushQ102H          ? 1'b0 : \n                          flushQ103H          ? 1'b0 : \n                          LoadHzrdDetectQ101H ? 1'b0 : \n                                                1'b1 ;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"flush signals will be discussed soon.")),(0,r.kt)("h3",{id:"lets-take-a-more-detailed-look"},"Lets take a more detailed look"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Step1  - load hazard detected (happens concurrently with step 2)"),(0,r.kt)("table",{parentName:"li"},(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Q100H"),(0,r.kt)("th",{parentName:"tr",align:null},"Q101H"),(0,r.kt)("th",{parentName:"tr",align:null},"Q102H"),(0,r.kt)("th",{parentName:"tr",align:null},"Notes"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Pc is stalled"),(0,r.kt)("td",{parentName:"tr",align:null},"add x3, x1, x4"),(0,r.kt)("td",{parentName:"tr",align:null},"lw x1, imm(x2)"),(0,r.kt)("td",{parentName:"tr",align:null},"LoadHzrdDetectQ101H = 1'b1"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Step2 - response to load hazard"),(0,r.kt)("table",{parentName:"li"},(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Q100H"),(0,r.kt)("th",{parentName:"tr",align:null},"Q101H"),(0,r.kt)("th",{parentName:"tr",align:null},"Q102H"),(0,r.kt)("th",{parentName:"tr",align:null},"Notes"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Pc is stalled, still points on add x3, x1, x4"),(0,r.kt)("td",{parentName:"tr",align:null},"addi x0, x0, 0 (NOP)"),(0,r.kt)("td",{parentName:"tr",align:null},"lw x1, imm(x2)"),(0,r.kt)("td",{parentName:"tr",align:null},"LoadHzrdDetectQ101H = 1'b1"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Step 3 - load hazard been handled"),(0,r.kt)("table",{parentName:"li"},(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Q100H"),(0,r.kt)("th",{parentName:"tr",align:null},"Q101H"),(0,r.kt)("th",{parentName:"tr",align:null},"Q102H"),(0,r.kt)("th",{parentName:"tr",align:null},"Q103H"),(0,r.kt)("th",{parentName:"tr",align:null},"Notes"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Enabe Pc"),(0,r.kt)("td",{parentName:"tr",align:null},"add x3, x1, x4"),(0,r.kt)("td",{parentName:"tr",align:null},"addi x0, x0, 0 (NOP)"),(0,r.kt)("td",{parentName:"tr",align:null},"lw x1, imm(x2)"),(0,r.kt)("td",{parentName:"tr",align:null},"LoadHzrdDetectQ101H = 1'b0"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Step 4"),(0,r.kt)("table",{parentName:"li"},(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Q100H"),(0,r.kt)("th",{parentName:"tr",align:null},"Q101H"),(0,r.kt)("th",{parentName:"tr",align:null},"Q102H"),(0,r.kt)("th",{parentName:"tr",align:null},"Q103H"),(0,r.kt)("th",{parentName:"tr",align:null},"Q104H"),(0,r.kt)("th",{parentName:"tr",align:null},"Notes"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Enabe Pc"),(0,r.kt)("td",{parentName:"tr",align:null},"new instruction"),(0,r.kt)("td",{parentName:"tr",align:null},"add x3, x1, x4"),(0,r.kt)("td",{parentName:"tr",align:null},"addi x0, x0, 0 (NOP)"),(0,r.kt)("td",{parentName:"tr",align:null},"lw x1, imm(x2)"),(0,r.kt)("td",{parentName:"tr",align:null},"forwarding")))))),(0,r.kt)("h3",{id:"control-hazard"},"Control Hazard"),(0,r.kt)("p",null,"Control hazard occurs when we have a branch or jump instruction. In this case we have to flush the pipeline and start fetching instructions from the new address."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Lets have a look at the following instruction that causes control hazard")),(0,r.kt)("p",null,"case1 (No Control Hazard)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"beq x1, x2, label1  #Q102H\nadd x3, x1, x4      #Q101H\nadd x5, x6, x7      #Q100H\n")),(0,r.kt)("p",null,"if x1 != x2 then we execute the instruction in Q101H and Q100H as usual."),(0,r.kt)("p",null,"case2 (Control Hazard)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"beq x1, x2, label1  #Q102H\nadd x3, x1, x4      #Q101H\nadd x5, x6, x7      #Q100H\n")),(0,r.kt)("p",null,"if x1 == x2 then it means that we have to flush the instructions in Q101H and Q100H and start fetching instructions from the new address."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"flush in our context means that we have to change instructions in Q100H and Q101H into NOP's. In that case we have to insert ",(0,r.kt)("strong",{parentName:"p"},"2 NOP's"),"."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"logic IndirectBranchQ102H;\nassign IndirectBranchQ102H = (CtrlQ102H.SelNextPcAluOutB && BranchCondMetQ102H) || (CtrlQ102H.SelNextPcAluOutJ);\nassign flushQ102H = IndirectBranchQ102H;\n`MAFIA_EN_DFF(flushQ103H , flushQ102H   , Clock , ReadyQ103H)\nassign InstructionQ101H = flushQ102H          ? NOP :\n                         flushQ103H          ? NOP :\n                         LoadHzrdDetectQ101H ? NOP : \n                                               PreInstructionQ101H;\nassign PreValidInstQ101H = flushQ102H          ? 1'b0 : \n                          flushQ103H          ? 1'b0 : \n                          LoadHzrdDetectQ101H ? 1'b0 : \n                                                1'b1 ;\n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"IndirectBranchQ102H is a signal that indicates if we have a branch or jump instruction. If we have a branch or jump instruction then we have to flush the pipeline.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"When flashQ102H is high, it means that we insert NOP into the actual Q101H stage. In order to insert another nop in the next cycle we use the following code to let the flash signal moves in  the pipeline"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"`MAFIA_EN_DFF(flushQ103H , flushQ102H   , Clock , ReadyQ103H)\n")),(0,r.kt)("h3",{id:"back-pressure"},"Back pressure"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Back pressure is a way we can stop the pipeline from moving forward. We use back pressure when we have a load hazard or memory access with read latency higher than 1. In this case we have to stop the pipeline and wait until the data becomes available.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"assign ReadyQ104H = (!CoreFreeze);\nassign ReadyQ103H = (!CoreFreeze);\nassign ReadyQ102H = (!CoreFreeze);//\nassign ReadyQ101H = (!CoreFreeze) && !(LoadHzrdDetectQ101H); //\nassign ReadyQ100H = (!CoreFreeze) && ReadyQ101H;//\n")),(0,r.kt)("h3",{id:"control-signals-goes-threw-the-pipeline"},"Control signals goes threw the pipeline"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"// Sample the Ctrl bits though the pipe\n`MAFIA_EN_RST_DFF(CtrlQ102H, CtrlQ101H, Clock, ReadyQ102H, Rst )\n`MAFIA_EN_DFF    (CtrlQ103H, CtrlQ102H, Clock, ReadyQ103H )\n`MAFIA_EN_DFF    (CtrlQ104H, CtrlQ103H, Clock, ReadyQ104H )\n")),(0,r.kt)("h3",{id:"ebreak-detection"},"ebreak detection"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Used for debug purposes to indicates end of program.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"logic ebreak_was_calledQ101H; \nassign ebreak_was_calledQ101H = (InstructionQ101H == 32'b000000000001_00000_000_00000_1110011);\n")),(0,r.kt)("h3",{id:"note"},"note"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"there are more code in the mini_core controller that we didn't discuss here because its relatively simple and easy to understand. For example, the code that responsible for the immediate types construction, AluOp construction, etc.")),(0,r.kt)("div",{className:"footnotes"},(0,r.kt)("hr",{parentName:"div"}),(0,r.kt)("ol",{parentName:"div"},(0,r.kt)("li",{parentName:"ol",id:"fn-1"},"NOP means addi x0, x0, 0 or 0x00000013H",(0,r.kt)("a",{parentName:"li",href:"#fnref-1",className:"footnote-backref"},"\u21a9")))))}u.isMDXComponent=!0}}]);