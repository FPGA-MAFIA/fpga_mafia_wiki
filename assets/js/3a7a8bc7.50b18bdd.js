"use strict";(self.webpackChunkmy_docs=self.webpackChunkmy_docs||[]).push([[9844],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>p});var i=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,i)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,i,n=function(e,t){if(null==e)return{};var a,i,n={},r=Object.keys(e);for(i=0;i<r.length;i++)a=r[i],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)a=r[i],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var c=i.createContext({}),s=function(e){var t=i.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},d=function(e){var t=s(e.components);return i.createElement(c.Provider,{value:t},e.children)},h="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},m=i.forwardRef((function(e,t){var a=e.components,n=e.mdxType,r=e.originalType,c=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),h=s(a),m=n,p=h["".concat(c,".").concat(m)]||h[m]||u[m]||r;return a?i.createElement(p,l(l({ref:t},d),{},{components:a})):i.createElement(p,l({ref:t},d))}));function p(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var r=a.length,l=new Array(r);l[0]=m;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o[h]="string"==typeof e?e:n,l[1]=o;for(var s=2;s<r;s++)l[s]=a[s];return i.createElement.apply(null,l)}return i.createElement.apply(null,a)}m.displayName="MDXCreateElement"},7360:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>s});var i=a(7462),n=(a(7294),a(3905));const r={},l=void 0,o={unversionedId:"cache/cheat_sheet",id:"cache/cheat_sheet",title:"cheat_sheet",description:"A",source:"@site/docs/cache/cheat_sheet.md",sourceDirName:"cache",slug:"/cache/cheat_sheet",permalink:"/fpga_mafia_wiki/docs/cache/cheat_sheet",draft:!1,editUrl:"https://github.com/FPGA-MAFIA/fpga_mafia_wiki/tree/main/docs/cache/cheat_sheet.md",tags:[],version:"current",frontMatter:{},sidebar:"Cache",previous:{title:"",permalink:"/fpga_mafia_wiki/docs/cache/cache_intro"},next:{title:"Cache HAS - High Level Specification",permalink:"/fpga_mafia_wiki/docs/cache/HAS/HAS_intro"}},c={},s=[{value:"A",id:"a",level:2},{value:"B",id:"b",level:2},{value:"C",id:"c",level:2},{value:"D",id:"d",level:2},{value:"E",id:"e",level:2},{value:"F",id:"f",level:2},{value:"G",id:"g",level:2},{value:"H",id:"h",level:2},{value:"I",id:"i",level:2},{value:"J",id:"j",level:2},{value:"K",id:"k",level:2},{value:"L",id:"l",level:2},{value:"M",id:"m",level:2},{value:"N",id:"n",level:2},{value:"O",id:"o",level:2},{value:"P",id:"p",level:2},{value:"Q",id:"q",level:2},{value:"R",id:"r",level:2},{value:"S",id:"s",level:2},{value:"T",id:"t",level:2},{value:"U",id:"u",level:2},{value:"V",id:"v",level:2},{value:"W",id:"w",level:2},{value:"X",id:"x",level:2},{value:"Y",id:"y",level:2},{value:"Z",id:"z",level:2}],d={toc:s},h="wrapper";function u(e){let{components:t,...a}=e;return(0,n.kt)(h,(0,i.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h2",{id:"a"},"A"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Allocation")," : The transaction(request) that enters the transaction queue (TQ). In our cache design allocate can also mean allocating a set (way allocation). Sometimes this allocation includes choosing a valid victim or allocating free way  ")),(0,n.kt)("h2",{id:"b"},"B"),(0,n.kt)("h2",{id:"c"},"C"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Cache line (CL)")," :  A block of contiguous memory addresses that are fetched from main memory and stored together in the cache. In our cache line its 128bits. ")),(0,n.kt)("h2",{id:"d"},"D"),(0,n.kt)("h2",{id:"e"},"E"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Evict")," : The process of erasing data from the cache to fill with new one."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Evict(dirty evict)")," : The remove data is not in the far memory(FM) yet and it must be updated there before it will be removed."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Evict(silent/clean evict)")," : The removed data has not been changed or already been updated in the far memory(FM). So it can be removed without any need to update thefar memory(FM).")),(0,n.kt)("h2",{id:"f"},"F"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Fill")," : Process of bringing data from far memory(FM) into the Cache."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"FM")," : Far memory. Refers to main memory storage. Mostly slow and big."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Free")," : A cache line (CL) that is either currently unoccupied or contains data that can be safely overwritten, usually because it has been evicted or invalidated.    ")),(0,n.kt)("h2",{id:"g"},"G"),(0,n.kt)("h2",{id:"h"},"H"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Hit"),' : Requested data is in the cache. In our design a Hit can have many meanings:  it can be a CL hit which takes place on the pipe. It can be a "hit on existing tq entry" where a new request overlaps with tq that being processed.')),(0,n.kt)("h2",{id:"i"},"I"),(0,n.kt)("h2",{id:"j"},"J"),(0,n.kt)("h2",{id:"k"},"K"),(0,n.kt)("h2",{id:"l"},"L"),(0,n.kt)("h2",{id:"m"},"M"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"MB")," : Merge buffer. Buffer that located inside the Transaction queue entry(TQ) used to merge CL of 128 width with shorter data like word, half word and bytes. The merge buffer merges the data from the fill (from the FM) and from the different writes (store) from the core. "),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Modified")," : Modified data is data that been changed inside the cache and it's an indication that means this data eventually must be dirty evicted. "),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Miss(Read)")," : Requested data is not in the cache"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Miss(Write)")," : Core refers to an address that its data not in the cache meaning that we have to fill it first.")),(0,n.kt)("h2",{id:"n"},"N"),(0,n.kt)("h2",{id:"o"},"O"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Offset")," : The position of the data within a cache line, indicating the exact byte or word location.")),(0,n.kt)("h2",{id:"p"},"P"),(0,n.kt)("h2",{id:"q"},"Q"),(0,n.kt)("h2",{id:"r"},"R"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Re-issue"),' : Action taken when an instruction or a data request cannot be immediately completed due to a cache miss or some other delay, and must be attempted again later. In that situation We are "stalling" the request on the re-issue buffer until we finish handling the other requests that caused the backpressue. (Tq full, read miss).'),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Read modify write")," : Process of modifying data by first reading it, update (modify) and write back. The read modified write takes place within the pipe for updating attributes in the tag array, and updating data in the cache array.")),(0,n.kt)("h2",{id:"s"},"S"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Set")," : A group of cache lines where data from any given block of main memory can be placed, according to the cache's set-associativity. It's actually specific bit's within the address which are used to group the entire memory space into groups that can potentially be allocated next to each other (in the same \"set\").")),(0,n.kt)("h2",{id:"t"},"T"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Tag")," : A portion of the physical memory address used to indicate the memory chunk ID from the far memory(FM). To be more precise: the tag is the portion of the PA (physical address), but each cl has a unique set+tag. So the 'cl' Id is actually both. Different cl can have the same rag. Different cl can have the same set. If both set and tag are the same for 2 cl - it's actually the same cl.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Transaction queue (TQ)")," : Mechanism used to manage and sequence the interactions (transactions) between the cache, the main memory and the core.",(0,n.kt)("br",{parentName:"p"}),"\n","A buffer or list that holds pending memory operations (such as reads, writes) that need to be executed by the cache system. This queue helps organize the order in which memory transactions should be processed, optimizing the cache's performance and ensuring consistency and efficiency in data handling."))),(0,n.kt)("h2",{id:"u"},"U"),(0,n.kt)("h2",{id:"v"},"V"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Valid")," :  Data inside the cache (CL) that not a garbage. For example: When access a CL in the first time for read before its been written the data there is not valid yet."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Victim"),' : When the cache set is full and we need to store new data,  we have to erase "old" data from it. The erased data is called victim. ')),(0,n.kt)("h2",{id:"w"},"W"),(0,n.kt)("h2",{id:"x"},"X"),(0,n.kt)("h2",{id:"y"},"Y"),(0,n.kt)("h2",{id:"z"},"Z"))}u.isMDXComponent=!0}}]);