"use strict";(self.webpackChunkmy_docs=self.webpackChunkmy_docs||[]).push([[4255],{3905:(t,e,a)=>{a.d(e,{Zo:()=>d,kt:()=>m});var n=a(7294);function i(t,e,a){return e in t?Object.defineProperty(t,e,{value:a,enumerable:!0,configurable:!0,writable:!0}):t[e]=a,t}function r(t,e){var a=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),a.push.apply(a,n)}return a}function o(t){for(var e=1;e<arguments.length;e++){var a=null!=arguments[e]?arguments[e]:{};e%2?r(Object(a),!0).forEach((function(e){i(t,e,a[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(a,e))}))}return t}function l(t,e){if(null==t)return{};var a,n,i=function(t,e){if(null==t)return{};var a,n,i={},r=Object.keys(t);for(n=0;n<r.length;n++)a=r[n],e.indexOf(a)>=0||(i[a]=t[a]);return i}(t,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(n=0;n<r.length;n++)a=r[n],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(t,a)&&(i[a]=t[a])}return i}var s=n.createContext({}),c=function(t){var e=n.useContext(s),a=e;return t&&(a="function"==typeof t?t(e):o(o({},e),t)),a},d=function(t){var e=c(t.components);return n.createElement(s.Provider,{value:e},t.children)},f="mdxType",u={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},p=n.forwardRef((function(t,e){var a=t.components,i=t.mdxType,r=t.originalType,s=t.parentName,d=l(t,["components","mdxType","originalType","parentName"]),f=c(a),p=i,m=f["".concat(s,".").concat(p)]||f[p]||u[p]||r;return a?n.createElement(m,o(o({ref:e},d),{},{components:a})):n.createElement(m,o({ref:e},d))}));function m(t,e){var a=arguments,i=e&&e.mdxType;if("string"==typeof t||i){var r=a.length,o=new Array(r);o[0]=p;var l={};for(var s in e)hasOwnProperty.call(e,s)&&(l[s]=e[s]);l.originalType=t,l[f]="string"==typeof t?t:i,o[1]=l;for(var c=2;c<r;c++)o[c]=a[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}p.displayName="MDXCreateElement"},3519:(t,e,a)=>{a.r(e),a.d(e,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var n=a(7462),i=(a(7294),a(3905));const r={},o="FIFO_arb MAS",l={unversionedId:"fabric/MAS_router/mas_fifo_arb",id:"fabric/MAS_router/mas_fifo_arb",title:"FIFO_arb MAS",description:"Brief Description:",source:"@site/docs/fabric/MAS_router/mas_fifo_arb.md",sourceDirName:"fabric/MAS_router",slug:"/fabric/MAS_router/mas_fifo_arb",permalink:"/fpga_mafia_wiki/docs/fabric/MAS_router/mas_fifo_arb",draft:!1,editUrl:"https://github.com/FPGA-MAFIA/fpga_mafia_wiki/tree/main/docs/fabric/MAS_router/mas_fifo_arb.md",tags:[],version:"current",frontMatter:{},sidebar:"Fabric",previous:{title:"Next_tile_fifo_arb MAS",permalink:"/fpga_mafia_wiki/docs/fabric/MAS_router/mas_next_tile_fifo_arb"},next:{title:"Arbiter MAS",permalink:"/fpga_mafia_wiki/docs/fabric/MAS_router/mas_arbiter"}},s={},c=[],d={toc:c},f="wrapper";function u(t){let{components:e,...r}=t;return(0,i.kt)(f,(0,n.Z)({},d,r,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"fifo_arb-mas"},"FIFO_arb MAS"),(0,i.kt)("h1",{id:"1-overview"},"1. Overview"),(0,i.kt)("p",null,"Brief Description:\nThis document outlines the micro-architecture of a fifo_arb module designed to manage multiple client requests and select a winner based on a predefined arbitration scheme. It interfaces with multiple fifos, arbitrates among them, and selects a winner to transmit data to the next tile."),(0,i.kt)("p",null,"Purpose and Functionality:\nThe fifo_arb module arbitrates among NUM_CLIENTS clients connected to different fifos. It uses an arbiter module to determine a winner based on the availability of data in the fifos and the readiness of the next tile to accept data."),(0,i.kt)("h1",{id:"2-block-diagram"},"2. Block Diagram"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"fifo_arb",src:a(8714).Z,width:"770",height:"649"})),(0,i.kt)("h1",{id:"3-interfaces"},"3. Interfaces"),(0,i.kt)("p",null,"Signal Descriptions:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Signal Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Direction"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"clk"),(0,i.kt)("td",{parentName:"tr",align:null},"Input"),(0,i.kt)("td",{parentName:"tr",align:null},"Clock signal.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"rst"),(0,i.kt)("td",{parentName:"tr",align:null},"Input"),(0,i.kt)("td",{parentName:"tr",align:null},"Reset signal.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"valid_alloc_req0, 1, 2, 3"),(0,i.kt)("td",{parentName:"tr",align:null},"Input"),(0,i.kt)("td",{parentName:"tr",align:null},"Signals indicating valid allocation requests from different clients (0 to NUM_CLIENTS-1).")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"alloc_req0, 1, 2, 3"),(0,i.kt)("td",{parentName:"tr",align:null},"Input"),(0,i.kt)("td",{parentName:"tr",align:null},"Transaction details of allocation requests from different clients (0 to NUM_CLIENTS-1).")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"out_ready_fifo0, 1, 2, 3"),(0,i.kt)("td",{parentName:"tr",align:null},"Output"),(0,i.kt)("td",{parentName:"tr",align:null},"Signals indicating whether the corresponding fifo (0 to NUM_CLIENTS-1) is ready to accept data.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"winner_req"),(0,i.kt)("td",{parentName:"tr",align:null},"Output"),(0,i.kt)("td",{parentName:"tr",align:null},"Transaction details of the winning request to be sent to the next tile.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"winner_req_valid"),(0,i.kt)("td",{parentName:"tr",align:null},"Output"),(0,i.kt)("td",{parentName:"tr",align:null},"Signal indicating the validity of the winning request.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"in_ready_north_arb_fifo"),(0,i.kt)("td",{parentName:"tr",align:null},"Input"),(0,i.kt)("td",{parentName:"tr",align:null},"Signal indicating the readiness of the arbiter fifo in the North direction.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"in_ready_east_arb_fifo"),(0,i.kt)("td",{parentName:"tr",align:null},"Input"),(0,i.kt)("td",{parentName:"tr",align:null},"Signal indicating the readiness of the arbiter fifo in the East direction.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"in_ready_south_arb_fifo"),(0,i.kt)("td",{parentName:"tr",align:null},"Input"),(0,i.kt)("td",{parentName:"tr",align:null},"Signal indicating the readiness of the arbiter fifo in the South direction.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"in_ready_west_arb_fifo"),(0,i.kt)("td",{parentName:"tr",align:null},"Input"),(0,i.kt)("td",{parentName:"tr",align:null},"Signal indicating the readiness of the arbiter fifo in the West direction.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"in_ready_local_arb_fifo"),(0,i.kt)("td",{parentName:"tr",align:null},"Input"),(0,i.kt)("td",{parentName:"tr",align:null},"Signal indicating the readiness of the arbiter fifo in the Local direction.")))),(0,i.kt)("h1",{id:"4-functional-description"},"4. Functional Description"),(0,i.kt)("p",null,"The fifo_arb module utilizes a complex Round Robin scheme to prioritize allocation requests from multiple clients. This scheme involves masking the Round Robin candidates with two conditions:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Valid Request Waiting to Pop: The Round Robin candidates are masked to exclude any clients whose allocation requests are not valid or ready to be processed. This ensures that only requests that are eligible for processing are considered in the Round Robin selection.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Target Readiness: Additionally, the Round Robin candidates are masked based on the readiness of the target FIFO arbiter to accept new requests. This means that even if a client has a valid request, it will only be considered if the target FIFO arbiter is ready to receive new requests. This condition optimizes the allocation process by ensuring that requests are processed efficiently and without unnecessary delays."))),(0,i.kt)("p",null,"The combination of these masking conditions in the Round Robin scheme enhances the overall efficiency and fairness of request allocation in the fifo_arb module, allowing it to effectively manage multiple client requests and select winners based on predefined criteria."),(0,i.kt)("p",null,"Here is a wave example of the fifo_arb:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"fifo_arb",src:a(2080).Z,width:"1600",height:"529"})),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"fifo_arb",src:a(337).Z,width:"1600",height:"508"})),(0,i.kt)("p",null,"In this example, the first waveform provides a visual representation of the input data being fed into each FIFO. It then demonstrates how this data is subsequently outputted in a serial manner, maintaining the order in which it was inputted. The second waveform showcases the arbitration process in action. This process is responsible for selecting the correct FIFO for data output, taking into consideration a set of predefined rules. These rules include the round robin scheduling algorithm, the application of masks to filter out certain FIFOs, and the use of the find_first method to determine the priority of the FIFOs."),(0,i.kt)("p",null,"And here we can see the behavior in a back-pressure:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"fifo_arb",src:a(2472).Z,width:"1600",height:"542"})),(0,i.kt)("p",null,"In this example, we're observing the 'valid_candidate' signal, which reflects the status of our FIFOs. Initially, we can see that all the FIFOs are intentionally filled to capacity, creating a deliberate blockage that prevents the acceptance of any new data. This is akin to purposely causing a traffic jam to test the system's response. When we decide to clear this intentional blockage, the FIFO arbiter, acting like a traffic controller, springs into action. It methodically starts to release the data from each of the FIFOs, gradually restoring the normal flow of data, much like easing a traffic jam to get cars moving smoothly again"),(0,i.kt)("h1",{id:"5-configuration-and-control"},"5. Configuration and Control"),(0,i.kt)("p",null,"Configuration Registers:"),(0,i.kt)("p",null,"NUM_CLIENTS: Defines the number of clients participating in arbitration.",(0,i.kt)("br",{parentName:"p"}),"\n","FIFO_ARB_FIFO_DEPTH: Defines the depth of each fifo in the fifo_arb module."),(0,i.kt)("h1",{id:"6-testing-and-verification"},"6. Testing and Verification"),(0,i.kt)("p",null,"In our tests, we aimed to achieve several objectives. One key goal was to ensure proper behavior during a back-pressure (BP) sequence. In a BP scenario, the system is intentionally put under stress by creating a bottleneck, causing data to accumulate upstream. The objective is to prevent data loss (no data drop) and maintain correct behavior under these conditions. Additionally, we aimed to ensure data integrity, making sure that the data remains uncorrupted and is accurately outputted in any use case."))}u.isMDXComponent=!0},8714:(t,e,a)=>{a.d(e,{Z:()=>n});const n=a.p+"assets/images/fifo_arb-3f0156630e8c1f9580135ae0f84798e4.jpg"},2080:(t,e,a)=>{a.d(e,{Z:()=>n});const n=a.p+"assets/images/fifo_arb1-186616eee4192d9899ccdab2266004fe.jpg"},337:(t,e,a)=>{a.d(e,{Z:()=>n});const n=a.p+"assets/images/fifo_arb2-c9c072f78d156c40882eabb39df9bfe2.jpg"},2472:(t,e,a)=>{a.d(e,{Z:()=>n});const n=a.p+"assets/images/fifo_arb_BP-22804bffac396e1c459e1677ac83e4ef.jpg"}}]);