"use strict";(self.webpackChunkmy_docs=self.webpackChunkmy_docs||[]).push([[4366],{3905:(t,e,a)=>{a.d(e,{Zo:()=>d,kt:()=>h});var n=a(7294);function r(t,e,a){return e in t?Object.defineProperty(t,e,{value:a,enumerable:!0,configurable:!0,writable:!0}):t[e]=a,t}function l(t,e){var a=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),a.push.apply(a,n)}return a}function i(t){for(var e=1;e<arguments.length;e++){var a=null!=arguments[e]?arguments[e]:{};e%2?l(Object(a),!0).forEach((function(e){r(t,e,a[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(a,e))}))}return t}function o(t,e){if(null==t)return{};var a,n,r=function(t,e){if(null==t)return{};var a,n,r={},l=Object.keys(t);for(n=0;n<l.length;n++)a=l[n],e.indexOf(a)>=0||(r[a]=t[a]);return r}(t,e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(t);for(n=0;n<l.length;n++)a=l[n],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(t,a)&&(r[a]=t[a])}return r}var p=n.createContext({}),s=function(t){var e=n.useContext(p),a=e;return t&&(a="function"==typeof t?t(e):i(i({},e),t)),a},d=function(t){var e=s(t.components);return n.createElement(p.Provider,{value:e},t.children)},u="mdxType",m={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},k=n.forwardRef((function(t,e){var a=t.components,r=t.mdxType,l=t.originalType,p=t.parentName,d=o(t,["components","mdxType","originalType","parentName"]),u=s(a),k=r,h=u["".concat(p,".").concat(k)]||u[k]||m[k]||l;return a?n.createElement(h,i(i({ref:e},d),{},{components:a})):n.createElement(h,i({ref:e},d))}));function h(t,e){var a=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var l=a.length,i=new Array(l);i[0]=k;var o={};for(var p in e)hasOwnProperty.call(e,p)&&(o[p]=e[p]);o.originalType=t,o[u]="string"==typeof t?t:r,i[1]=o;for(var s=2;s<l;s++)i[s]=a[s];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}k.displayName="MDXCreateElement"},6502:(t,e,a)=>{a.r(e),a.d(e,{assets:()=>p,contentTitle:()=>i,default:()=>m,frontMatter:()=>l,metadata:()=>o,toc:()=>s});var n=a(7462),r=(a(7294),a(3905));const l={},i="tq_entry",o={unversionedId:"cache/MAS/tq_entry",id:"cache/MAS/tq_entry",title:"tq_entry",description:"The transaction queue entry Micro-Architecture-Specification",source:"@site/docs/cache/MAS/tq_entry.md",sourceDirName:"cache/MAS",slug:"/cache/MAS/tq_entry",permalink:"/fpga_mafia_wiki/docs/cache/MAS/tq_entry",draft:!1,editUrl:"https://github.com/FPGA-MAFIA/fpga_mafia_wiki/tree/main/docs/cache/MAS/tq_entry.md",tags:[],version:"current",frontMatter:{},sidebar:"Cache",previous:{title:"tag_data_arrays",permalink:"/fpga_mafia_wiki/docs/cache/MAS/tag_data_arrays"},next:{title:"tq",permalink:"/fpga_mafia_wiki/docs/cache/MAS/tq"}},p={},s=[{value:"Block Diagram",id:"block-diagram",level:2},{value:"Top level interface",id:"top-level-interface",level:2},{value:"Main components:",id:"main-components",level:2},{value:"TQ entry Flops:",id:"tq-entry-flops",level:3},{value:"Motivation:",id:"motivation",level:4},{value:"Table of Flops:",id:"table-of-flops",level:4},{value:"TQ entry FSM:",id:"tq-entry-fsm",level:3},{value:"Motivation:",id:"motivation-1",level:4},{value:"Table of FSM states:",id:"table-of-fsm-states",level:4},{value:"Diagram of the TQ entry FSM:",id:"diagram-of-the-tq-entry-fsm",level:4},{value:"Typical FSM flow:",id:"typical-fsm-flow",level:2},{value:"Write Hit:",id:"write-hit",level:3},{value:"Write Miss:",id:"write-miss",level:3},{value:"Read Hit:",id:"read-hit",level:3},{value:"Read Miss:",id:"read-miss",level:3},{value:"TQ entry merge_buffer:",id:"tq-entry-merge_buffer",level:3},{value:"Motivation:",id:"motivation-2",level:4},{value:"Examples:",id:"examples",level:4}],d={toc:s},u="wrapper";function m(t){let{components:e,...l}=t;return(0,r.kt)(u,(0,n.Z)({},d,l,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"tq_entry"},"tq_entry"),(0,r.kt)("p",null,"The transaction queue entry Micro-Architecture-Specification"),(0,r.kt)("h2",{id:"block-diagram"},"Block Diagram"),(0,r.kt)("p",null,"TODO - insert the block diagram"),(0,r.kt)("h2",{id:"top-level-interface"},"Top level interface"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Size"),(0,r.kt)("th",{parentName:"tr",align:null},"Direction"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"clk"),(0,r.kt)("td",{parentName:"tr",align:null},"1 bit"),(0,r.kt)("td",{parentName:"tr",align:null},"In"),(0,r.kt)("td",{parentName:"tr",align:null},"Clock signal for synchronous operation")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"rst"),(0,r.kt)("td",{parentName:"tr",align:null},"1 bit"),(0,r.kt)("td",{parentName:"tr",align:null},"In"),(0,r.kt)("td",{parentName:"tr",align:null},"Reset signal for resetting the module")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"entry_id"),(0,r.kt)("td",{parentName:"tr",align:null},"3 bits"),(0,r.kt)("td",{parentName:"tr",align:null},"In"),(0,r.kt)("td",{parentName:"tr",align:null},"Entry identifier for this module")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"core2cache_req"),(0,r.kt)("td",{parentName:"tr",align:null},"60 bits"),(0,r.kt)("td",{parentName:"tr",align:null},"In"),(0,r.kt)("td",{parentName:"tr",align:null},"Core-to-cache request data")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"allocate_entry"),(0,r.kt)("td",{parentName:"tr",align:null},"1 bit"),(0,r.kt)("td",{parentName:"tr",align:null},"In"),(0,r.kt)("td",{parentName:"tr",align:null},"Signal to allocate an entry")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"fm2cache_rd_rsp"),(0,r.kt)("td",{parentName:"tr",align:null},"149 bits"),(0,r.kt)("td",{parentName:"tr",align:null},"In"),(0,r.kt)("td",{parentName:"tr",align:null},"FM-to-cache read response data")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"pipe_lu_rsp_q3"),(0,r.kt)("td",{parentName:"tr",align:null},"164 bits"),(0,r.kt)("td",{parentName:"tr",align:null},"In"),(0,r.kt)("td",{parentName:"tr",align:null},"Pipe lookup response data")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"first_fill"),(0,r.kt)("td",{parentName:"tr",align:null},"1 bit"),(0,r.kt)("td",{parentName:"tr",align:null},"In"),(0,r.kt)("td",{parentName:"tr",align:null},"Signal indicating the first fill")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"cancel_core_req"),(0,r.kt)("td",{parentName:"tr",align:null},"1 bit"),(0,r.kt)("td",{parentName:"tr",align:null},"In"),(0,r.kt)("td",{parentName:"tr",align:null},"Signal to cancel the core request")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"tq_entry"),(0,r.kt)("td",{parentName:"tr",align:null},"162 bits"),(0,r.kt)("td",{parentName:"tr",align:null},"Out"),(0,r.kt)("td",{parentName:"tr",align:null},"TQ entry data output")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"next_tq_entry"),(0,r.kt)("td",{parentName:"tr",align:null},"162 bits"),(0,r.kt)("td",{parentName:"tr",align:null},"Out"),(0,r.kt)("td",{parentName:"tr",align:null},"Next TQ entry data output")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"rd_req_hit_mb"),(0,r.kt)("td",{parentName:"tr",align:null},"1 bit"),(0,r.kt)("td",{parentName:"tr",align:null},"Out"),(0,r.kt)("td",{parentName:"tr",align:null},"Signal indicating a read request hit")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"wr_req_hit_mb"),(0,r.kt)("td",{parentName:"tr",align:null},"1 bit"),(0,r.kt)("td",{parentName:"tr",align:null},"Out"),(0,r.kt)("td",{parentName:"tr",align:null},"Signal indicating a write request hit")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"free_entry"),(0,r.kt)("td",{parentName:"tr",align:null},"1 bit"),(0,r.kt)("td",{parentName:"tr",align:null},"Out"),(0,r.kt)("td",{parentName:"tr",align:null},"Signal indicating a free entry")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"fill_entry"),(0,r.kt)("td",{parentName:"tr",align:null},"1 bit"),(0,r.kt)("td",{parentName:"tr",align:null},"Out"),(0,r.kt)("td",{parentName:"tr",align:null},"Signal indicating a fill entry")))),(0,r.kt)("h2",{id:"main-components"},"Main components:"),(0,r.kt)("h3",{id:"tq-entry-flops"},"TQ entry Flops:"),(0,r.kt)("h4",{id:"motivation"},"Motivation:"),(0,r.kt)("p",null,"In the design of our cache architecture, the 'tq entry' plays a crucial role in managing the interactions between the core processor and the cache subsystem. It serves as the entry point for incoming requests, tracks the state of each request, and handles data merging and storage. To provide a comprehensive understanding of its operation, we present a detailed analysis of the flip-flops used within the 'tq entry' module. These flip-flops control various aspects of the entry's behavior, such as request indications, merge buffer management, and address tracking. By documenting and analyzing these flip-flops, we aim to shed light on the inner workings of this essential component, facilitating both comprehension and potential enhancements to our cache architecture."),(0,r.kt)("h4",{id:"table-of-flops"},"Table of Flops:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Size"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"when & how data writes"),(0,r.kt)("th",{parentName:"tr",align:null},"who consumes the data"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"state"),(0,r.kt)("td",{parentName:"tr",align:null},"3  bits"),(0,r.kt)("td",{parentName:"tr",align:null},"State of the TQ Entry"),(0,r.kt)("td",{parentName:"tr",align:null},"State transition"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"merge_buffer_e_modified"),(0,r.kt)("td",{parentName:"tr",align:null},"4  bits"),(0,r.kt)("td",{parentName:"tr",align:null},"Indication of merge Buffer modification"),(0,r.kt)("td",{parentName:"tr",align:null},"Bit is set when data in MB is modified"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"rd_indication"),(0,r.kt)("td",{parentName:"tr",align:null},"1  bits"),(0,r.kt)("td",{parentName:"tr",align:null},"Read indication"),(0,r.kt)("td",{parentName:"tr",align:null},"Bit is set when read request is processed"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"wr_indication"),(0,r.kt)("td",{parentName:"tr",align:null},"1  bits"),(0,r.kt)("td",{parentName:"tr",align:null},"Write indication"),(0,r.kt)("td",{parentName:"tr",align:null},"Bit is set when write request is processed"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"merge_buffer_data"),(0,r.kt)("td",{parentName:"tr",align:null},"128 bits"),(0,r.kt)("td",{parentName:"tr",align:null},"Data stored in the merge buffer"),(0,r.kt)("td",{parentName:"tr",align:null},"When merge buffer data is updated"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"cl_address"),(0,r.kt)("td",{parentName:"tr",align:null},"16 bits"),(0,r.kt)("td",{parentName:"tr",align:null},"Cache Line Adress"),(0,r.kt)("td",{parentName:"tr",align:null},"When cache line address is set"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"cl_word_offset"),(0,r.kt)("td",{parentName:"tr",align:null},"2  bits"),(0,r.kt)("td",{parentName:"tr",align:null},"Word offset within a Cache Line"),(0,r.kt)("td",{parentName:"tr",align:null},"When word offset is set"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"reg_id"),(0,r.kt)("td",{parentName:"tr",align:null},"6  bits"),(0,r.kt)("td",{parentName:"tr",align:null},"Register identifier"),(0,r.kt)("td",{parentName:"tr",align:null},"When register identifier is set"),(0,r.kt)("td",{parentName:"tr",align:null})))),(0,r.kt)("h3",{id:"tq-entry-fsm"},"TQ entry FSM:"),(0,r.kt)("h4",{id:"motivation-1"},"Motivation:"),(0,r.kt)("p",null,"In the heart of our cache architecture lies the TQ (Transaction Queue) entry Finite State Machine (FSM). This FSM orchestrates the intricate dance between core processor requests, cache hits and misses, data merging, and state transitions within each TQ entry. Understanding the TQ entry FSM is paramount for comprehending the inner workings of our cache system. This section provides a comprehensive overview of the TQ entry FSM, shedding light on the transitions, conditions, and actions that shape the behavior of each entry."),(0,r.kt)("h4",{id:"table-of-fsm-states"},"Table of FSM states:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Possible Next State"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"S_IDLE"),(0,r.kt)("td",{parentName:"tr",align:null},"S_LU_CORE"),(0,r.kt)("td",{parentName:"tr",align:null},"Waiting for a core request to allocate the entry")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"S_LU_CORE"),(0,r.kt)("td",{parentName:"tr",align:null},"S_IDLE / S_MB_WAIT_FILL"),(0,r.kt)("td",{parentName:"tr",align:null},"Core requests are being processed, and interactions with LU pipe may occur")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"S_MB_WAIT_FILL"),(0,r.kt)("td",{parentName:"tr",align:null},"S_MB_FILL_READY"),(0,r.kt)("td",{parentName:"tr",align:null},"The module is waiting for a cache fill response.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"S_MB_FILL_READY"),(0,r.kt)("td",{parentName:"tr",align:null},"S_IDLE"),(0,r.kt)("td",{parentName:"tr",align:null},"The module is ready to send a cache fill response to the LU pipe")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"S_ERROR"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"Indicates an unexpected or erroneous situation")))),(0,r.kt)("h4",{id:"diagram-of-the-tq-entry-fsm"},"Diagram of the TQ entry FSM:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"TQ entry FSM",src:a(1985).Z,width:"787",height:"634"})),(0,r.kt)("h2",{id:"typical-fsm-flow"},"Typical FSM flow:"),(0,r.kt)("h3",{id:"write-hit"},"Write Hit:"),(0,r.kt)("p",null,"S_IDLE -> S_LU_CORE -> S_IDLE"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"New write request from the core")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"TQ entry is allocated in parallel to the pipe lookup")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"TQ entry merge buffer is updated speculatively with the new request data")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Lookup response is received as a hit - the TQ data is discarded. Entry returns to S_IDLE"),(0,r.kt)("p",{parentName:"li"},'(There is a case of B2B writes where the TQ state will not return to S_IDLE until the "last write" to the same CL responds from lookup. See Merge Buffer Behavior for more details.)'))),(0,r.kt)("h3",{id:"write-miss"},"Write Miss:"),(0,r.kt)("p",null,"S",(0,r.kt)("em",{parentName:"p"},"IDLE -> S_LU_CORE->S_MB_WAIT_FILL -> S_MB_FILL_READY -> S")," IDLE "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"New write request from the core  "),(0,r.kt)("li",{parentName:"ul"},"TQ entry is allocated in parallel to the pipe lookup  "),(0,r.kt)("li",{parentName:"ul"},"TQ entry merge buffer is updated speculatively with the new request data.  "),(0,r.kt)("li",{parentName:"ul"},"Lookup response is received as miss - moving to the MB_WAIT_FILL state.  "),(0,r.kt)("li",{parentName:"ul"},"Far memory response is received, Merge buffer updates the write with the fill data,moving to the MB_FILL_READY state.  "),(0,r.kt)("li",{parentName:"ul"},'The TQ entry wins the arbitration to send the "Fill" to the lookup pipe -> movingto the S_IDLE state.',(0,r.kt)("br",{parentName:"li"}),'Note: We have a guaranty that the fill lookup will always win cache allocation. Meaning there is no "miss" for a fill request. this allows us to move to the S_IDLE state without waiting for the lookup response.')),(0,r.kt)("h3",{id:"read-hit"},"Read Hit:"),(0,r.kt)("p",null,"S",(0,r.kt)("em",{parentName:"p"},"IDLE -> S_LU_CORE->S")," IDLE "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"New read request from the core  "),(0,r.kt)("li",{parentName:"ul"},"TQ entry is allocated in parallel to the pipe lookup  "),(0,r.kt)("li",{parentName:"ul"},"TQ entry merge buffer is updated speculatively with the new request data  "),(0,r.kt)("li",{parentName:"ul"},"Lookup response is received as hit - the TQ data is discarded. Entry returns to S_IDLE  ")),(0,r.kt)("h3",{id:"read-miss"},"Read Miss:"),(0,r.kt)("p",null,"S",(0,r.kt)("em",{parentName:"p"},"IDLE -> S_LU_CORE->S_MB_WAIT_FILL -> S_MB_FILL_READY -> S")," IDLE  "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"New read request from the core  "),(0,r.kt)("li",{parentName:"ul"},"TQ entry is allocated in parallel to the pipe lookup  "),(0,r.kt)("li",{parentName:"ul"},"There is no Data updated to the TQ entry merge buffer (this is a read request)  "),(0,r.kt)("li",{parentName:"ul"},"Lookup response is received as miss - moving to the MB_WAIT_FILL state.  "),(0,r.kt)("li",{parentName:"ul"},"Far memory response is received, Merge buffer updates the write with the fill data, moving to the MB_FILL_READY state."),(0,r.kt)("li",{parentName:"ul"},'The TQ entry wins the arbitration to send the "Fill" to the lookup pipe -> moving to the S_IDLE state.',(0,r.kt)("br",{parentName:"li"}),"Note: We have a guaranty that the fill lookup will always win cache allocation.",(0,r.kt)("br",{parentName:"li"}),'Meaning there is no "miss" for a fill request.',(0,r.kt)("br",{parentName:"li"}),"this allows us to move to the S_IDLE state without waiting for the lookup response.")),(0,r.kt)("h3",{id:"tq-entry-merge_buffer"},"TQ entry merge_buffer:"),(0,r.kt)("h4",{id:"motivation-2"},"Motivation:"),(0,r.kt)("p",null,"The merge_buffer is a buffer in our TQ that will store partial data during the time we are waiting for the Cache Line Data to be filled by the Far Memory.\nEvery entry in the TQ is linked to a Merge Buffer entry then we need to take care that every request to the same Cache-Line will never allocate a new entry if there already is an entry in the TQ for that specific Cache-Line."),(0,r.kt)("h4",{id:"examples"},"Examples:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Write after Write")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If the first write hits:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The merge buffer will be discarded due to all the data is already updates in the cache."),(0,r.kt)("li",{parentName:"ul"},"The TQ entry will not go back to the S_IDLE state as long there are write request to that same CL in the lookup Pipe.",(0,r.kt)("br",{parentName:"li"}),'This is achieved by having a "req_match_in_pipe" indication in the lookup response struct.'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If the first write misses:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The merge buffer will be merge with the second write data."),(0,r.kt)("li",{parentName:"ul"},'The first write will respond with a "miss" which will cause the TQ entry to go to the MB_WAIT_FILL state.'),(0,r.kt)("li",{parentName:"ul"},"Any new write to that same CL will be merged with the merge buffer data."),(0,r.kt)("li",{parentName:"ul"},"Once the Far memory response is received, the merge buffer will be updated with the fill data."),(0,r.kt)("li",{parentName:"ul"},'The TQ entry will win the arbitration to send the "Fill" to the lookup pipe -> moving to the S_IDLE state. '))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Read after Write")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"If the first write request hits:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The merge buffer will be discarded due to all the data is already updates in the cache."),(0,r.kt)("li",{parentName:"ul"},"The TQ entry will not go back to the S_IDLE state as long there are request to that same CL in the lookup Pipe.",(0,r.kt)("br",{parentName:"li"}),'This is achieved by having a "req_match_in_pipe" indication in the lookup response struct.')))))))}m.isMDXComponent=!0},1985:(t,e,a)=>{a.d(e,{Z:()=>n});const n=a.p+"assets/images/tq_entry_fsm-720e0aec0add346514196761de62bc2e.jpg"}}]);