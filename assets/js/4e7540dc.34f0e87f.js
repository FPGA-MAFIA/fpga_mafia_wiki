"use strict";(self.webpackChunkmy_docs=self.webpackChunkmy_docs||[]).push([[259],{3905:(e,t,n)=>{n.d(t,{Zo:()=>s,kt:()=>p});var r=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=r.createContext({}),m=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},s=function(e){var t=m(e.components);return r.createElement(c.Provider,{value:t},e.children)},_="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},f=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,c=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),_=m(n),f=i,p=_["".concat(c,".").concat(f)]||_[f]||d[f]||o;return n?r.createElement(p,a(a({ref:t},s),{},{components:n})):r.createElement(p,a({ref:t},s))}));function p(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,a=new Array(o);a[0]=f;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l[_]="string"==typeof e?e:i,a[1]=l;for(var m=2;m<o;m++)a[m]=n[m];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}f.displayName="MDXCreateElement"},7813:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>m});var r=n(7462),i=(n(7294),n(3905));const o={},a=void 0,l={unversionedId:"rvc/core_verification/rv32i_ref_model",id:"rvc/core_verification/rv32i_ref_model",title:"rv32i_ref_model",description:"rv32irefmodel",source:"@site/docs/rvc/core_verification/rv32i_ref_model.md",sourceDirName:"rvc/core_verification",slug:"/rvc/core_verification/rv32i_ref_model",permalink:"/fpga_mafia_wiki/docs/rvc/core_verification/rv32i_ref_model",draft:!1,editUrl:"https://github.com/FPGA-MAFIA/fpga_mafia_wiki/tree/main/docs/rvc/core_verification/rv32i_ref_model.md",tags:[],version:"current",frontMatter:{},sidebar:"RISCV_Cores",previous:{title:"regressions",permalink:"/fpga_mafia_wiki/docs/rvc/core_verification/regressions"},next:{title:"print_sanity",permalink:"/fpga_mafia_wiki/docs/rvc/core_verification/print_sanity"}},c={},m=[{value:"Introduction",id:"introduction",level:3},{value:"ref32i_ref_model interface",id:"ref32i_ref_model-interface",level:3},{value:"Instantiation of the model",id:"instantiation-of-the-model",level:3}],s={toc:m},_="wrapper";function d(e){let{components:t,...n}=e;return(0,i.kt)(_,(0,r.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"rv32i_ref_model"),(0,i.kt)("h3",{id:"introduction"},"Introduction"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"rv32i_ref_model")," serves as a foundational model that implements the RV32I RISC-V ISA. This model, composed in a behavioral style using SystemVerilog, is designed to aid in the verification of other cores. It is employed with the assumption of its correctness, contributing to the validation process. This core acts loke a single-cycle CPU."),(0,i.kt)("li",{parentName:"ul"},"The model can be instantiated in a testbench of core which is being verified. Than we can use some ",(0,i.kt)("a",{parentName:"li",href:"/fpga_mafia_wiki/docs/rvc/core_verification/checker_tasks"},"tasks")," to compare between the signals of the core and the model. If the signals are not the same, the tasks will raise an error depending on the task."),(0,i.kt)("li",{parentName:"ul"},"The model is located at ",(0,i.kt)("inlineCode",{parentName:"li"},"/verif/rv32i_ref/tb/rv32i_ref.sv"),". Take a look at that file to understand its functionality, its relatively easy \ud83d\ude0a")),(0,i.kt)("h3",{id:"ref32i_ref_model-interface"},"ref32i_ref_model interface"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"module rv32i_ref \n#(  \n    parameter I_MEM_LSB = 'h0_0000,\n    parameter I_MEM_MSB = 'h1_0000 - 1'h1,\n    parameter D_MEM_LSB = 'h1_0000,\n    parameter D_MEM_MSB = 'h2_0000 - 1'h1 \n) (\n    input clk,\n    input rst,\n    input run\n);\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"I_MEM_LSB")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"I_MEM_MSB")," are the lower and upper bounds of the instruction memory. ",(0,i.kt)("inlineCode",{parentName:"li"},"D_MEM_LSB")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"D_MEM_MSB")," are the lower and upper bounds of the data memory.   "),(0,i.kt)("li",{parentName:"ul"},"clk: clock signal. rst: reset signal. run: run signal, when run is high, the model will retire the instruction. Its possible to put some logic on ",(0,i.kt)("inlineCode",{parentName:"li"},"run")," when we want to stop the model from executing instructions which are not relevant to the test or to the ref model.")),(0,i.kt)("h3",{id:"instantiation-of-the-model"},"Instantiation of the model"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The best way to understand how to instantiate the model is to look at the testbench of the core which is being verified. In the next example we will look at ",(0,i.kt)("inlineCode",{parentName:"li"},"mini_core tb.sv"),", that testbench is located at ",(0,i.kt)("inlineCode",{parentName:"li"},"/verif/mini_core/tb/mini_core_tb.sv"),".   ")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"rv32i_ref\n# (\n    .I_MEM_LSB (I_MEM_OFFSET_MINI),\n    .I_MEM_MSB (I_MEM_MSB_MINI),\n    .D_MEM_LSB (D_MEM_OFFSET_MINI),\n    .D_MEM_MSB (D_MEM_MSB_MINI)\n)  rv32i_ref (\n.clk    (Clk),\n.rst    (Rst),\n.run    (1'b1) // set the RUN only when the mini_core DUT is retiring the instruction.\n               // every time the run is set, the next instruction is executed\n);\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The parameters ",(0,i.kt)("inlineCode",{parentName:"p"},"I_MEM_LSB"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"I_MEM_MSB"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"D_MEM_LSB")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"D_MEM_MSB")," are located in the package file. In the case of the mini_core, the package file is located at ",(0,i.kt)("inlineCode",{parentName:"p"},"/source/mini_core/mini_core_pkg.sv"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In the following code we force the verified core and rv32i_ref_model core with the same instruction and data memory. ")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The tasks ",(0,i.kt)("inlineCode",{parentName:"p"},"get_rf_write")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"get_ref_rf_write")," are used to compare between the register file of the core and the rv32i_ref_model. "))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'integer file;\ninitial begin: test_seq\n    if ($value$plusargs ("STRING=%s", test_name))\n        $display("STRING value %s", test_name);\n    //======================================\n    //load the program to the DUT & reference model\n    //======================================\n    // Make sure inst_mem.sv exists\n    file = $fopen({"../../../target/mini_core/tests/",test_name,"/gcc_files/inst_mem.sv"}, "r");\n    if (!file) begin\n        $error("the file: ../../../target/mini_core/tests/%s/gcc_files/inst_mem.sv does not exist", test_name);\n        $display("ERROR: inst_mem.sv file does not exist");\n        $finish;\n    end\n    $readmemh({"../../../target/mini_core/tests/",test_name,"/gcc_files/inst_mem.sv"} , IMem);\n    force mini_core_top.mini_mem_wrap.i_mem.mem = IMem; //backdoor to actual memory\n    force rv32i_ref.imem                        = IMem; //backdoor to reference model memory\n    //load the data to the DUT & reference model \n    file = $fopen({"../../../target/mini_core/tests/",test_name,"/gcc_files/data_mem.sv"}, "r");\n    if (file) begin\n        $fclose(file);\n        $readmemh({"../../../target/mini_core/tests/",test_name,"/gcc_files/data_mem.sv"} , DMem);\n        force mini_core_top.mini_mem_wrap.d_mem.mem = DMem; //backdoor to actual memory\n        force rv32i_ref.dmem                        = DMem; //backdoor to reference model memory\n        #10\n        release mini_core_top.mini_mem_wrap.d_mem.mem;\n        release rv32i_ref.dmem;\n    end\n    \n    //=======================================\n    // enable the checker data collection (monitor)\n    //=======================================\n    fork\n    get_rf_write();\n    get_ref_rf_write();\n    begin wait(mini_core_top.mini_core.mini_core_ctrl.ebreak_was_calledQ101H == 1\'b1);\n        eot(.msg("ebreak was called"));\n    end\n    join\n\nend // test_seq\n')))}d.isMDXComponent=!0}}]);