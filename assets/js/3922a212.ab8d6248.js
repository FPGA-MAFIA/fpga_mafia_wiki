"use strict";(self.webpackChunkmy_docs=self.webpackChunkmy_docs||[]).push([[9887],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>g});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=a.createContext({}),o=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=o(e.components);return a.createElement(c.Provider,{value:t},e.children)},u="mdxType",_={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,l=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=o(n),m=i,g=u["".concat(c,".").concat(m)]||u[m]||_[m]||l;return n?a.createElement(g,r(r({ref:t},p),{},{components:n})):a.createElement(g,r({ref:t},p))}));function g(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=n.length,r=new Array(l);r[0]=m;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[u]="string"==typeof e?e:i,r[1]=s;for(var o=2;o<l;o++)r[o]=n[o];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},8035:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>_,frontMatter:()=>l,metadata:()=>s,toc:()=>o});var a=n(7462),i=(n(7294),n(3905));const l={},r="Common examples",s={unversionedId:"TFM/verilog/examples",id:"TFM/verilog/examples",title:"Common examples",description:"Mux",source:"@site/docs/TFM/verilog/examples.md",sourceDirName:"TFM/verilog",slug:"/TFM/verilog/examples",permalink:"/fpga_mafia_wiki/docs/TFM/verilog/examples",draft:!1,editUrl:"https://github.com/FPGA-MAFIA/fpga_mafia_wiki/tree/main/docs/TFM/verilog/examples.md",tags:[],version:"current",frontMatter:{},sidebar:"TFM",previous:{title:"intro",permalink:"/fpga_mafia_wiki/docs/TFM/verilog/intro"},next:{title:"Intro to System-Verilog",permalink:"/fpga_mafia_wiki/docs/TFM/verilog/basic_concepts"}},c={},o=[{value:"Mux",id:"mux",level:2},{value:"Most compact:",id:"most-compact",level:3},{value:"Naive If else",id:"naive-if-else",level:3},{value:"compact if else - &quot;? : &quot;",id:"compact-if-else-----",level:3},{value:"using case",id:"using-case",level:3},{value:"AND_OR mux",id:"and_or-mux",level:3},{value:"Counter",id:"counter",level:2},{value:"State-Machine",id:"state-machine",level:2},{value:"Find_First",id:"find_first",level:2},{value:"Shift register",id:"shift-register",level:2},{value:"Register-File",id:"register-file",level:2},{value:"Pipe-Line",id:"pipe-line",level:2}],p={toc:o},u="wrapper";function _(e){let{components:t,...n}=e;return(0,i.kt)(u,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"common-examples"},"Common examples"),(0,i.kt)("h2",{id:"mux"},"Mux"),(0,i.kt)("p",null,"In System Verilog, there are many ways to code a mux.",(0,i.kt)("br",{parentName:"p"}),"\n","We will show a couple of examples and what are the implications of them"),(0,i.kt)("p",null,"Lets use this as the signals:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-systemverilog"},"logic [3:0] in [3:0];\nlogic [1:0] enc_sel;\nlogic [3:0] out ;\n")),(0,i.kt)("h3",{id:"most-compact"},"Most compact:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-systemverilog"},"assign out = in[enc_sel];\n")),(0,i.kt)("h3",{id:"naive-if-else"},"Naive If else"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-systemverilog"},"always_comb begin\n  if      (enc_sel == 2'b00) out =in[0];\n  else if (enc_sel == 2'b01) out =in[1];\n  else if (enc_sel == 2'b10) out =in[2];\n  else if (enc_sel == 2'b11) out =in[3];\nend\n")),(0,i.kt)("h3",{id:"compact-if-else-----"},'compact if else - "? : "'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-systemverilog"},"assign out = (enc_sel == 2'b00) ? in[0] : \n             (enc_sel == 2'b01) ? in[1] : \n             (enc_sel == 2'b10) ? in[2] : \n                                  in[3] ; // (enc_sel == 2'b11) \n")),(0,i.kt)("h3",{id:"using-case"},"using case"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-systemverilog"},"always_comb begin\n  unique case (enc_sel) \n  2'b00   : out = in[0];\n  2'b01   : out = in[1];\n  2'b10   : out = in[2];\n  2'b11   : out = in[3];\n  default : out = in[0];\n  endcase \nend\n")),(0,i.kt)("h3",{id:"and_or-mux"},"AND_OR mux"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-systemverilog"},"logic [MSB:0] in [3:0];\nlogic [MSB:0] dec_sel;\nlogic [MSB:0] out ;\n\n\n out  = ({MSB{dec_sel[0]}} & in[0] ) |\n        ({MSB{dec_sel[1]}} & in[1] ) |\n        ({MSB{dec_sel[2]}} & in[2] ) |\n        ({MSB{dec_sel[3]}} & in[3] ) ;\n\n")),(0,i.kt)("h2",{id:"counter"},"Counter"),(0,i.kt)("p",null,"using macro:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-systemverilog"},"assign next_count = count +1;\n`DFF(count, next_count,clk)\n")),(0,i.kt)("p",null,"alternatively can write smaller - but I do not recommend it.\nWe like using the ",(0,i.kt)("inlineCode",{parentName:"p"},"next_<name>")," with FF"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-systemverilog"},"`DFF(count, (count + 1) , clk)\n")),(0,i.kt)("p",null,"The macro translates into:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-systemverilog"},"assign next_count = count +1;\nalways_ff  @(posedge clk) begin\n      count <= next_count; \nend\n")),(0,i.kt)("h2",{id:"state-machine"},"State-Machine"),(0,i.kt)("p",null,"Guidelines:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Use an Enumerate value for the state"),(0,i.kt)("li",{parentName:"ul"},"Have a simple Flip-Flop to sample the state.",(0,i.kt)("br",{parentName:"li"}),"Example:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-systemverilog"},"`RST_VAL_DFF(state, next_sate, clk, rst, IDLE)\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"in an 'always_comb' block, calculate the next_state as a function of the current state + other condition.  ",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Use a ",(0,i.kt)("inlineCode",{parentName:"li"},"unique casez")),(0,i.kt)("li",{parentName:"ul"},"May use ",(0,i.kt)("inlineCode",{parentName:"li"},"priority casez")," if appropriate)"),(0,i.kt)("li",{parentName:"ul"},"Make sure to have a default value"),(0,i.kt)("li",{parentName:"ul"})))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-systemverilog"},"//==========================\n// The state Machine:\n//==========================\nalways_comb begin\nnext_state = state;\nunique casez (state)\n    IDLE: begin\n        if( condition == CONDITION_MET) begin\n            next_state = FIRST_STATE;\n        end // if\n    end // IDLE\n...\n    default: begin\n            next_state = state;\n    end\nendcase // casez\nend // always_comb\n")),(0,i.kt)("p",null,"See the example of traffic_light state_machine\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/amichai-bd/fpga_mafia/discussions/27"},"https://github.com/amichai-bd/fpga_mafia/discussions/27")),(0,i.kt)("h2",{id:"find_first"},"Find_First"),(0,i.kt)("h2",{id:"shift-register"},"Shift register"),(0,i.kt)("p",null,"This is a compact and nice way to code a Shift register:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-systemverilog"},"logic [MSB_DATA:0] shift_register [MSB_SHFT:0]\n\nassign shift_register[0] = data_in[MSB_DATA:0];\n`DFF(shift_register[MSB_SHFT:1] , shift_register[MSB_SHFT-1:0] , clk)\n")),(0,i.kt)("h2",{id:"register-file"},"Register-File"),(0,i.kt)("p",null,"example of a duel read single write register file:  "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-systemverilog"},"logic [31:0] Register [31:0]; \n//logic [31:0][31:0] Register ; //this is valid option to.\nlogic [4:0] RegDst;\nlogic [4:0] RegSrc1;\nlogic [4:0] RegSrc2;\n//---- The Register File  ------\n`EN_DFF(Register[RegDst] , RegWrData , Clk , CtrlRegWrEn)\n// --- read Register File --------\nassign RegRdData1 = Register[RegSrc1];\nassign RegRdData2 = Register[RegSrc2];\n\n")),(0,i.kt)("h2",{id:"pipe-line"},"Pipe-Line"),(0,i.kt)("p",null,'For a pipe where we accumulate & calculate different attributes we can use a "struct" with relevant fields, and keep adding/overriding then down the pipe:\nlu_valid, lu_set,lu_tag,hit, miss, mb_hit_cancel, set_ways_mru',"[3:0]",", set_ways_valid","[3:0]",", set_ways_victim","[3:0]",",set_ways_hit","[3:0]",", set_ways_enc_hit","[2:0]",", fill_cl_data","[127:0]",", fill_valid, lu_opcode","[1:0]"," // RD_LU, WR_LU,FILL_LU"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Each cycle has the sampled version and the updated version (cache_pipe_lu_q2 ,pre_cache_pipe_lu_q2)"),(0,i.kt)("li",{parentName:"ul"},"Make sure that the assignments all match the correct suffix (q1,q2,q3...)"),(0,i.kt)("li",{parentName:"ul"},"The suffix (pipe stage) should change only when it goes through a Fli-Flop\n",(0,i.kt)("inlineCode",{parentName:"li"},"`DFF(pre_cache_pipe_lu_q2, cache_pipe_lu_q1, clk)"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-systemverilog"},"//====================\n//    Pipe stage 1\n//====================\nalways_comb begin\n  cache_pipe_lu_q1 ='0; //this is the default value\n  cache_pipe_lu_q1.valid     = ...q1 ;\n  cache_pipe_lu_q1.opcode    = ...q1 ;\n  cache_pipe_lu_q1.set       =  ...q1 ;\n  cache_pipe_lu_q1.tag       =  ...q1 ;\n  cache_pipe_lu_q1.fill_data =  ...q1 ;\nend //always_comb\n\n\n//====================\n//    Pipe stage 2\n//====================\n`DFF(pre_cache_pipe_lu_q2, cache_pipe_lu_q1, clk)\nalways_comb begin\n  cache_pipe_lu_q2                         =pre_cache_pipe_lu_q2; //this is the default value\n  cache_pipe_lu_q2.set_ways_valid = ...q2;\n  cache_pipe_lu_q2.set_ways_tags = ...q2;\n  cache_pipe_lu_q2.set_ways_mru  = ...q2;\n  cache_pipe_lu_q2.set_ways_hit    = ...q2;\n  cache_pipe_lu_q2.hit                    = ...q2;\n  cache_pipe_lu_q2.miss                = ...q2;\n  cache_pipe_lu_q2.data_array_address   = {pre_cache_pipe_lu_q2.set , pre_cache_pipe_lu_q2.set_ways_enc_hit};\n\nend //always_comb\n\n//====================\n//    Pipe stage 3\n//====================\n`DFF(pre_cache_pipe_lu_q3, cache_pipe_lu_q2, clk)\nalways_comb begin\n  cache_pipe_lu_q3                        =pre_cache_pipe_lu_q3; //this is the default value\n  .. \nend\n")))}_.isMDXComponent=!0}}]);