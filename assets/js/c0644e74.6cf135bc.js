"use strict";(self.webpackChunkmy_docs=self.webpackChunkmy_docs||[]).push([[4255],{3905:(t,e,n)=>{n.d(e,{Zo:()=>c,kt:()=>m});var a=n(7294);function r(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function i(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function l(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?i(Object(n),!0).forEach((function(e){r(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function o(t,e){if(null==t)return{};var n,a,r=function(t,e){if(null==t)return{};var n,a,r={},i=Object.keys(t);for(a=0;a<i.length;a++)n=i[a],e.indexOf(n)>=0||(r[n]=t[n]);return r}(t,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);for(a=0;a<i.length;a++)n=i[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(r[n]=t[n])}return r}var s=a.createContext({}),d=function(t){var e=a.useContext(s),n=e;return t&&(n="function"==typeof t?t(e):l(l({},e),t)),n},c=function(t){var e=d(t.components);return a.createElement(s.Provider,{value:e},t.children)},u="mdxType",p={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},f=a.forwardRef((function(t,e){var n=t.components,r=t.mdxType,i=t.originalType,s=t.parentName,c=o(t,["components","mdxType","originalType","parentName"]),u=d(n),f=r,m=u["".concat(s,".").concat(f)]||u[f]||p[f]||i;return n?a.createElement(m,l(l({ref:e},c),{},{components:n})):a.createElement(m,l({ref:e},c))}));function m(t,e){var n=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var i=n.length,l=new Array(i);l[0]=f;var o={};for(var s in e)hasOwnProperty.call(e,s)&&(o[s]=e[s]);o.originalType=t,o[u]="string"==typeof t?t:r,l[1]=o;for(var d=2;d<i;d++)l[d]=n[d];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}f.displayName="MDXCreateElement"},3519:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>s,contentTitle:()=>l,default:()=>p,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var a=n(7462),r=(n(7294),n(3905));const i={},l="FIFO_arb MAS",o={unversionedId:"fabric/MAS_router/mas_fifo_arb",id:"fabric/MAS_router/mas_fifo_arb",title:"FIFO_arb MAS",description:"Brief Description:",source:"@site/docs/fabric/MAS_router/mas_fifo_arb.md",sourceDirName:"fabric/MAS_router",slug:"/fabric/MAS_router/mas_fifo_arb",permalink:"/fpga_mafia_wiki/docs/fabric/MAS_router/mas_fifo_arb",draft:!1,editUrl:"https://github.com/FPGA-MAFIA/fpga_mafia_wiki/tree/main/docs/fabric/MAS_router/mas_fifo_arb.md",tags:[],version:"current",frontMatter:{},sidebar:"Fabric",previous:{title:"Next_tile_fifo_arb MAS",permalink:"/fpga_mafia_wiki/docs/fabric/MAS_router/mas_next_tile_fifo_arb"},next:{title:"Arbiter MAS",permalink:"/fpga_mafia_wiki/docs/fabric/MAS_router/mas_arbiter"}},s={},d=[],c={toc:d},u="wrapper";function p(t){let{components:e,...i}=t;return(0,r.kt)(u,(0,a.Z)({},c,i,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"fifo_arb-mas"},"FIFO_arb MAS"),(0,r.kt)("h1",{id:"1-overview"},"1. Overview"),(0,r.kt)("p",null,"Brief Description:\nThis document outlines the micro-architecture of a fifo_arb module designed to manage multiple client requests and select a winner based on a predefined arbitration scheme. It interfaces with multiple fifos, arbitrates among them, and selects a winner to transmit data to the next tile."),(0,r.kt)("p",null,"Purpose and Functionality:\nThe fifo_arb module arbitrates among NUM_CLIENTS clients connected to different fifos. It uses an arbiter module to determine a winner based on the availability of data in the fifos and the readiness of the next tile to accept data."),(0,r.kt)("h1",{id:"2-block-diagram"},"2. Block Diagram"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"fifo_arb",src:n(8714).Z,width:"770",height:"649"})),(0,r.kt)("h1",{id:"3-interfaces"},"3. Interfaces"),(0,r.kt)("p",null,"Signal Descriptions:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Signal Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Direction"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"clk"),(0,r.kt)("td",{parentName:"tr",align:null},"Input"),(0,r.kt)("td",{parentName:"tr",align:null},"Clock signal.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"rst"),(0,r.kt)("td",{parentName:"tr",align:null},"Input"),(0,r.kt)("td",{parentName:"tr",align:null},"Reset signal.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"valid_alloc_req0, 1, 2, 3"),(0,r.kt)("td",{parentName:"tr",align:null},"Input"),(0,r.kt)("td",{parentName:"tr",align:null},"Signals indicating valid allocation requests from different clients (0 to NUM_CLIENTS-1).")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"alloc_req0, 1, 2, 3"),(0,r.kt)("td",{parentName:"tr",align:null},"Input"),(0,r.kt)("td",{parentName:"tr",align:null},"Transaction details of allocation requests from different clients (0 to NUM_CLIENTS-1).")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"out_ready_fifo0, 1, 2, 3"),(0,r.kt)("td",{parentName:"tr",align:null},"Output"),(0,r.kt)("td",{parentName:"tr",align:null},"Signals indicating whether the corresponding fifo (0 to NUM_CLIENTS-1) is ready to accept data.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"winner_req"),(0,r.kt)("td",{parentName:"tr",align:null},"Output"),(0,r.kt)("td",{parentName:"tr",align:null},"Transaction details of the winning request to be sent to the next tile.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"winner_req_valid"),(0,r.kt)("td",{parentName:"tr",align:null},"Output"),(0,r.kt)("td",{parentName:"tr",align:null},"Signal indicating the validity of the winning request.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"in_ready_north_arb_fifo"),(0,r.kt)("td",{parentName:"tr",align:null},"Input"),(0,r.kt)("td",{parentName:"tr",align:null},"Signal indicating the readiness of the arbiter fifo in the North direction.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"in_ready_east_arb_fifo"),(0,r.kt)("td",{parentName:"tr",align:null},"Input"),(0,r.kt)("td",{parentName:"tr",align:null},"Signal indicating the readiness of the arbiter fifo in the East direction.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"in_ready_south_arb_fifo"),(0,r.kt)("td",{parentName:"tr",align:null},"Input"),(0,r.kt)("td",{parentName:"tr",align:null},"Signal indicating the readiness of the arbiter fifo in the South direction.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"in_ready_west_arb_fifo"),(0,r.kt)("td",{parentName:"tr",align:null},"Input"),(0,r.kt)("td",{parentName:"tr",align:null},"Signal indicating the readiness of the arbiter fifo in the West direction.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"in_ready_local_arb_fifo"),(0,r.kt)("td",{parentName:"tr",align:null},"Input"),(0,r.kt)("td",{parentName:"tr",align:null},"Signal indicating the readiness of the arbiter fifo in the Local direction.")))),(0,r.kt)("h1",{id:"4-functional-description"},"4. Functional Description"),(0,r.kt)("p",null,"The fifo_arb module utilizes a complex Round Robin scheme to prioritize allocation requests from multiple clients. This scheme involves masking the Round Robin candidates with two conditions:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Valid Request Waiting to Pop: The Round Robin candidates are masked to exclude any clients whose allocation requests are not valid or ready to be processed. This ensures that only requests that are eligible for processing are considered in the Round Robin selection.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Target Readiness: Additionally, the Round Robin candidates are masked based on the readiness of the target FIFO arbiter to accept new requests. This means that even if a client has a valid request, it will only be considered if the target FIFO arbiter is ready to receive new requests. This condition optimizes the allocation process by ensuring that requests are processed efficiently and without unnecessary delays."))),(0,r.kt)("p",null,"The combination of these masking conditions in the Round Robin scheme enhances the overall efficiency and fairness of request allocation in the fifo_arb module, allowing it to effectively manage multiple client requests and select winners based on predefined criteria."),(0,r.kt)("h1",{id:"5-configuration-and-control"},"5. Configuration and Control"),(0,r.kt)("p",null,"Configuration Registers:"),(0,r.kt)("p",null,"NUM_CLIENTS: Defines the number of clients participating in arbitration.",(0,r.kt)("br",{parentName:"p"}),"\n","FIFO_ARB_FIFO_DEPTH: Defines the depth of each fifo in the fifo_arb module."),(0,r.kt)("h1",{id:"6-performance-and-characteristics"},"6. Performance and Characteristics"),(0,r.kt)("p",null,"Throughput:\nDependent on the clock frequency."),(0,r.kt)("p",null,"Latency:\nDependent on the arbitration scheme and fifo availability."),(0,r.kt)("h1",{id:"7-error-handling-and-exceptions"},"7. Error Handling and Exceptions"),(0,r.kt)("p",null,"The module does not explicitly include error handling mechanisms in this design."),(0,r.kt)("h1",{id:"8-testing-and-verification"},"8. Testing and Verification"),(0,r.kt)("p",null,"In the verification sidebar."))}p.isMDXComponent=!0},8714:(t,e,n)=>{n.d(e,{Z:()=>a});const a=n.p+"assets/images/fifo_arb-3f0156630e8c1f9580135ae0f84798e4.jpg"}}]);