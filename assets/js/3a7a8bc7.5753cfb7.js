"use strict";(self.webpackChunkmy_docs=self.webpackChunkmy_docs||[]).push([[9844],{3905:(e,t,a)=>{a.d(t,{Zo:()=>s,kt:()=>p});var r=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},i=Object.keys(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var c=r.createContext({}),d=function(e){var t=r.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},s=function(e){var t=d(e.components);return r.createElement(c.Provider,{value:t},e.children)},h="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,c=e.parentName,s=o(e,["components","mdxType","originalType","parentName"]),h=d(a),m=n,p=h["".concat(c,".").concat(m)]||h[m]||u[m]||i;return a?r.createElement(p,l(l({ref:t},s),{},{components:a})):r.createElement(p,l({ref:t},s))}));function p(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,l=new Array(i);l[0]=m;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o[h]="string"==typeof e?e:n,l[1]=o;for(var d=2;d<i;d++)l[d]=a[d];return r.createElement.apply(null,l)}return r.createElement.apply(null,a)}m.displayName="MDXCreateElement"},7360:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var r=a(7462),n=(a(7294),a(3905));const i={},l=void 0,o={unversionedId:"cache/cheat_sheet",id:"cache/cheat_sheet",title:"cheat_sheet",description:"A",source:"@site/docs/cache/cheat_sheet.md",sourceDirName:"cache",slug:"/cache/cheat_sheet",permalink:"/fpga_mafia_wiki/docs/cache/cheat_sheet",draft:!1,editUrl:"https://github.com/FPGA-MAFIA/fpga_mafia_wiki/tree/main/docs/cache/cheat_sheet.md",tags:[],version:"current",frontMatter:{},sidebar:"Cache",previous:{title:"",permalink:"/fpga_mafia_wiki/docs/cache/cache_intro"},next:{title:"Cache HAS - High Level Specification",permalink:"/fpga_mafia_wiki/docs/cache/HAS/HAS_intro"}},c={},d=[{value:"A",id:"a",level:2},{value:"B",id:"b",level:2},{value:"C",id:"c",level:2},{value:"D",id:"d",level:2},{value:"E",id:"e",level:2},{value:"F",id:"f",level:2},{value:"G",id:"g",level:2},{value:"H",id:"h",level:2},{value:"I",id:"i",level:2},{value:"J",id:"j",level:2},{value:"K",id:"k",level:2},{value:"L",id:"l",level:2},{value:"M",id:"m",level:2},{value:"N",id:"n",level:2},{value:"O",id:"o",level:2},{value:"P",id:"p",level:2},{value:"Q",id:"q",level:2},{value:"R",id:"r",level:2},{value:"S",id:"s",level:2},{value:"T",id:"t",level:2},{value:"U",id:"u",level:2},{value:"V",id:"v",level:2},{value:"W",id:"w",level:2},{value:"X",id:"x",level:2},{value:"Y",id:"y",level:2},{value:"Z",id:"z",level:2}],s={toc:d},h="wrapper";function u(e){let{components:t,...a}=e;return(0,n.kt)(h,(0,r.Z)({},s,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h2",{id:"a"},"A"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Allocation")," : The transaction(request) that enters the transaction queue (TQ) ")),(0,n.kt)("h2",{id:"b"},"B"),(0,n.kt)("h2",{id:"c"},"C"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Cache line (CL)")," :  A block of contiguous memory addresses that are fetched from main memory and stored together in the cache. In our cache line its 128bits. ")),(0,n.kt)("h2",{id:"d"},"D"),(0,n.kt)("h2",{id:"e"},"E"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Evict")," : The process of erasing data from the cache to fill with new one."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Evict(dirty evict)")," : The remove data is not in the far memory(FM) yet and it must be updated there before it will be removed."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Evict(silent/clean evict)")," : The removed data has not been changed or already been updated in the far memory(FM). So it can be removed without any need to update thefar memory(FM).")),(0,n.kt)("h2",{id:"f"},"F"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Fill")," : Process of bringing data from far memory(FM) into the Cache."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"FM")," : Far memory. Refers to main memory storage. Mostly slow and big."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Free")," : A cache line (CL) that is either currently unoccupied or contains data that can be safely overwritten, usually because it has been evicted or invalidated.    ")),(0,n.kt)("h2",{id:"g"},"G"),(0,n.kt)("h2",{id:"h"},"H"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Hit")," : Requested data is in the cache.")),(0,n.kt)("h2",{id:"i"},"I"),(0,n.kt)("h2",{id:"j"},"J"),(0,n.kt)("h2",{id:"k"},"K"),(0,n.kt)("h2",{id:"l"},"L"),(0,n.kt)("h2",{id:"m"},"M"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"MB")," : Merge buffer. Buffer that located inside the Transaction queue entry(TQ) used to merge CL of 128 width with shorter data like word, half word and bytes. "),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Modified")," : Modified data is data that been changed inside the cache and has not been stored back into far memory(FM) causing the far memory(FM) to be not updated. "),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Miss(Read)")," : Requested data is not in the cache"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Miss(Write)")," : Core refers to an address that its data not in the cache meaning that we have to fill it first.")),(0,n.kt)("h2",{id:"n"},"N"),(0,n.kt)("h2",{id:"o"},"O"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Offset")," : The position of the data within a cache line, indicating the exact byte or word location.")),(0,n.kt)("h2",{id:"p"},"P"),(0,n.kt)("h2",{id:"q"},"Q"),(0,n.kt)("h2",{id:"r"},"R"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Re-issue")," : Action taken when an instruction or a data request cannot be immediately completed due to a cache miss or some other delay, and must be attempted again later. In that situation the request temporary removed from pipeline for other requests."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Read modify write")," : Process of modifying data by first reading it, update (modify) and write back. For example: If we want to update word in a cache line than we first read the cache line and merge it using merge buffer with the write data.")),(0,n.kt)("h2",{id:"s"},"S"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Set")," : A group of cache lines where data from any given block of main memory can be placed, according to the cache's set-associativity.")),(0,n.kt)("h2",{id:"t"},"T"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Tag")," : A portion of the physical memory address used to indicate the memory chunk ID from the far memory(FM). "),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Transaction queue (TQ)")," : Mechanism used to manage and sequence the interactions (transactions) between the cache, the main memory and the core.",(0,n.kt)("br",{parentName:"li"}),"A buffer or list that holds pending memory operations (such as reads, writes) that need to be executed by the cache system. This queue helps organize the order in which memory transactions should be processed, optimizing the cache's performance and ensuring consistency and efficiency in data handling.")),(0,n.kt)("h2",{id:"u"},"U"),(0,n.kt)("h2",{id:"v"},"V"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Valid")," :  Data inside the cache (CL) that not a garbage. For example: When access a CL in the first time for read before its been written the data there is not valid yet."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Victim"),' : When the cache set is full and we need to store new data,  we have to erase "old" data from it. The erased data is called victim. ')),(0,n.kt)("h2",{id:"w"},"W"),(0,n.kt)("h2",{id:"x"},"X"),(0,n.kt)("h2",{id:"y"},"Y"),(0,n.kt)("h2",{id:"z"},"Z"))}u.isMDXComponent=!0}}]);