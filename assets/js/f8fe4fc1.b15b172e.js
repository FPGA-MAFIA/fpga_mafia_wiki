"use strict";(self.webpackChunkmy_docs=self.webpackChunkmy_docs||[]).push([[1019],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>p});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),f=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=f(e.components);return i.createElement(l.Provider,{value:t},e.children)},_="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},d=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),_=f(n),d=a,p=_["".concat(l,".").concat(d)]||_[d]||u[d]||r;return n?i.createElement(p,o(o({ref:t},c),{},{components:n})):i.createElement(p,o({ref:t},c))}));function p(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[_]="string"==typeof e?e:a,o[1]=s;for(var f=2;f<r;f++)o[f]=n[f];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}d.displayName="MDXCreateElement"},3709:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>f});var i=n(7462),a=(n(7294),n(3905));const r={},o=void 0,s={unversionedId:"fabric/verification/verification_fifo_arb",id:"fabric/verification/verification_fifo_arb",title:"verification_fifo_arb",description:"Strategy",source:"@site/docs/fabric/verification/verification_fifo_arb.md",sourceDirName:"fabric/verification",slug:"/fabric/verification/verification_fifo_arb",permalink:"/fpga_mafia_wiki/docs/fabric/verification/verification_fifo_arb",draft:!1,editUrl:"https://github.com/FPGA-MAFIA/fpga_mafia_wiki/tree/main/docs/fabric/verification/verification_fifo_arb.md",tags:[],version:"current",frontMatter:{},sidebar:"Fabric",previous:{title:"verification_fabric",permalink:"/fpga_mafia_wiki/docs/fabric/verification/verification_fabric"}},l={},f=[{value:"Strategy",id:"strategy",level:2},{value:"Code",id:"code",level:3}],c={toc:f},_="wrapper";function u(e){let{components:t,...n}=e;return(0,a.kt)(_,(0,i.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"strategy"},"Strategy"),(0,a.kt)("p",null,"We devided our goal into 3 main topics."),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Creating meaningful sequences that will assure that our design is robust and can handle pressure."),(0,a.kt)("li",{parentName:"ol"},"Creating reliable checkers."),(0,a.kt)("li",{parentName:"ol"},"Creatung a lot of robust tests that will push the design to his limits.\nNote - we made here an assamption that if the FIFO_arb will be good then the FIFO and the Arbiter will be good as well. ")),(0,a.kt)("h3",{id:"code"},"Code"),(0,a.kt)("p",null,'Our FIFO_arb verification created with the least amount of pre assumptions like size of FIFO, depth of FIFO and even the amount of FIFO\'s in the FIFO_arb (even though it was not in our design, we wnated to ensure the most robust DUT).\nThe module of the TB called "router_tb" and it is also contains one basic test for the router.\nThe important signals and parameters in the TB are:'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-systemverilog"},"parameter V_REQUESTS   = 10;\nparameter V_FIFO_DEPTH = 4;\nparameter V_NUM_FIFO   = 4;  // number of fifos to exercise in the test (HW is always 4, simulation may stimuli only some of them)\nparameter V_NO_BACK_PRESSURE = 0; // used to disable back pressure in the test which will cause a failure in the test\nparameter V_MAX_DELAY  = 5; // max delay in the test\nparameter V_BACK_PRESURE = 10;\nlogic              clk;\nlogic              rst;\nstatic t_tile_trans ref_fifo_Q [3:0][$];\nstatic t_tile_trans ref_outputs_Q [$];  \n")),(0,a.kt)("p",null,"We created the fifo_arb inputs and outputs, the inputs are 4 FIFO's (can be less then 4) that are creatd in software (to be used as RM), they are type of dynamic array in SV that called queue.The output is the winner of each transaction. the type of the FIFO's is t_tile_trans.\nwe also created some parameters that can change by user definition.\nThe main sequence is:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-systemverilog"},"  fork \n      run_fifo_arb_test(test_name);\n      fifo_arb_get_inputs();\n      fifo_arb_get_outputs();\n  join\n")),(0,a.kt)("p",null,"We are activating three tasks in parallel, run the test and two collectors that will collect the input and the output of the FIFO_arb (for each FIFO obviousley)."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"run_fifo_arb_test(test_name);"),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-systemverilog"},'task run_fifo_arb_test(input string test);\n delay(30);\n // ====================\n // fifo_arb tests:\n // ====================\n if (test == "fifo_arb_simple") begin\n    `include "fifo_arb_simple.sv"\n end else if(test == "fifo_arb_single_fifo_full_BW")begin\n   `include "fifo_arb_single_fifo_full_BW.sv"\n end else if(test == "fifo_arb_all_fifo_full_BW")begin\n   `include "fifo_arb_all_fifo_full_BW.sv"\n end else if(test == "fifo_arb_Assertion_test")begin\n   `include "fifo_arb_Assertion_test.sv"\n end else if(test == "fifo_arb_back_pressure")begin\n   `include "fifo_arb_back_pressure.sv"\n end else begin\n   $error(" [ERROR] : test %s not found",test);\n end\nendtask\n\n')),(0,a.kt)("p",{parentName:"li"}," This task is running the relevant test that was chosen by the user. ")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"fifo_arb_get_inputs();"),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-systemverilog"},'task automatic fifo_arb_get_inputs();\nfor(int i = 0; i<4; i++) begin\n automatic int index = i;\n fork begin\n   forever begin\n     wait(valid_alloc_req[index] == 1\'b1);\n     #0;\n     cnt_in = cnt_in + 1;\n     $display("input of fifo number %0d and CNT_IN = %0d",index,cnt_in);\n     ref_fifo_Q[index].push_back(alloc_req[index]);\n     wait(valid_alloc_req[index] == 1\'b0);  \n   end\n end \n forever begin\n   wait(fifo_arb_ins.arb.winner_dec_id[index] == 1\'b1);\n   if(winner_req_valid == 1\'b0) $display("problem in fifo %0d at time %0t",index,$time);\n   cnt_fifo_pop = cnt_fifo_pop + 1;\n   $display("cnt_fifo_pop = %0d in fifo %0d at time %0t winner_valid is %0b and fifo_pop is %4b",cnt_fifo_pop,index,$time,winner_req_valid,fifo_arb_ins.arb.winner_dec_id);\n   wait(fifo_arb_ins.arb.winner_dec_id[index] == 1\'b0);\n end\n join_none\nend\nendtask\n')),(0,a.kt)("p",{parentName:"li"}," This task is using a technique that creating all the fifo's at the same time in parallel, we are using fork - join_none to put the process in the background so the code will continue to run. in this way we created a for loop that generates 4 software fifo's in parallel.\nEach FIFO is getting a thread of his own that including two sub threds that runs in parallel as well.The first sub thread is collecting all the transaction inputs of the relevant FIFO, the second sub thread is collecting the output of each FIFO, this way we can know where was an issue in a more specific way.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"fifo_arb_get_outputs();"),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-systemverilog"},'task automatic fifo_arb_get_outputs();\nint fifo_pop_cnt = 0;\nfork\nforever begin\n @(winner_req);\n #0;\n if(winner_req_valid == 1\'b1)begin\n cnt_out = cnt_out + 1;\n ref_outputs_Q.push_back(winner_req);\n $display("CNT OUT = %0d",cnt_out);\n end\nend\njoin_none\nendtask\n')),(0,a.kt)("p",{parentName:"li"}," This task, also run's in the bacground, simply collect all the output transactions from the fifo_arb and save them in a queue for post process.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Post process.\nThe last part of the verification is the DI_checker (Data Integrity).\nafter the sequence is finished we are activating a checker that will compare the data from the inputs and the  output."))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-systemverilog"},'task fifo_arb_DI_checker(); // pseudo SB\nautomatic bit check = 0;\nrepeat(5000)begin\n  foreach(ref_fifo_Q[i,j])begin\n    foreach(ref_outputs_Q[k])begin\n      if(ref_fifo_Q[i][j] == ref_outputs_Q[k])begin\n        ref_fifo_Q[i].delete(j);\n        ref_outputs_Q.delete(k);\n      end\n     end\n    end\n   end\n  if(ref_outputs_Q.size()!= 0)begin\n    $error("output list not empty ,data is and size %0d",ref_outputs_Q.size());\n    check = 1\'b1;\n  end\n  for(int i=0;i<4;i++)begin\n    if(ref_fifo_Q[i].size() != 0)begin\n      check = 1\'b1;\n       $error("input list not empty for fifo %0d , and size %0d",i,ref_fifo_Q[i].size());\n    end   \n  end\n  if(check == 1\'b0)\n    $display("DI CHECKER: DATA IS CORRECT");\nendtask\n')),(0,a.kt)("p",null,"This task is simply checks if all the inputs did got out from the fifo_arb. it iterates all the arrays and compare the input array to the output array, if there is a mismatch then the checker will allert in which fifo and whuch transaction we had this issue."),(0,a.kt)("h1",{id:"tests"},"Tests"),(0,a.kt)("p",null,"We wanted to create the strongest tests that will push our design to its limits.\nWe have 5 tests that can be paramtrize. "),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"fifo_arb_simple."),(0,a.kt)("li",{parentName:"ol"},"fifo_arb_single_fifo_full_BW."),(0,a.kt)("li",{parentName:"ol"},"fifo_arb_all_fifo_full_BW."),(0,a.kt)("li",{parentName:"ol"},"fifo_arb_Assertion_test."),(0,a.kt)("li",{parentName:"ol"},"fifo_arb_back_pressure.")),(0,a.kt)("p",null,"Tests 1 and 2 are very simple and created as first step just to see the flow of the design."),(0,a.kt)("p",null,"Test 3 is a very powerfull test, it activating all fifo's in the same time and pushes random data in random times to each one of them."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-systemverilog"},'int cycle_delay;\nint cycle_delay_arb;\nint delay_test;\nstatic int fifo_finish;\nfor(int i = 0; i<V_NUM_FIFO; i++) begin\n  automatic int fifo = i;\n  fork begin \n    $display("this is fifo %d at time %t",fifo,$time);\n    for(int j = 0; j < V_REQUESTS; j++)begin\n        wait(fifo_arb_ins.full[fifo] == \'0);\n        cycle_delay = $urandom_range(0, V_MAX_DELAY);\n        delay(cycle_delay);  \n        $display("fifo %d and request %0d at time: %0t and full[%0d] is %0b and full is %4b",fifo,j,$time,fifo,fifo_arb_ins.full[fifo],fifo_arb_ins.full );\n        fifo_arb_gen_trans(fifo);\n    end\n  fifo_finish = fifo_finish + 1;\n  $display("############# this is FIFO_FINISH %0d in fifo %0d at time %t",fifo_finish,fifo,$time);\n\n  end \n  join_none\nend\nfork : in_ready_arb_fifo_fork\n    begin\n    forever begin\n    cycle_delay_arb = $urandom_range(2, V_MAX_DELAY + 15);\n    rand_in_ready = $urandom_range(0,15);\n    delay(cycle_delay_arb);\n    in_ready_arb_fifo = {5{rand_in_ready}};\n    end\n  end\n  begin\n    delay_test = V_REQUESTS/V_NUM_FIFO;\n    delay(delay_test);\n  end\njoin_any\ndisable in_ready_arb_fifo_fork;\nin_ready_arb_fifo = 5\'b11111;\nwait(fifo_finish == (V_NUM_FIFO));\n$display("############# this is empty %4b at time %t befote wait",fifo_arb_ins.empty,$time);\nwait(fifo_arb_ins.empty == 4\'b1111);\n$display("############# after wait FIFO_FINISH %0d at time %0t",fifo_finish,$time);\n$display("############# this is empty %4b at time %t after wait",fifo_arb_ins.empty,$time);\n')),(0,a.kt)("p",null,"This test is activating all FIFO's using fork - join_none and randomize the data and the delay.\nthe number of transaction is defined by the user as long as the number of FIFO's and the depth of each FIFO. We created a lot of tests that changes those parameters."),(0,a.kt)("p",null,"The assertion_test is not in the GK, it is only a test that will violate the rule of our assertion so we can verify that out assertions are correct."),(0,a.kt)("p",null,"and the last test is a back_pressure_test. In this test we wanted to check a real scenario that the fifo_arb will need to handle with. in this case we fill the fifo_arb completley and we didnt allow the transaction to get out of the fifo_arb. we expect that the fifo_arb wont take any new request until the pressure is down. we did it by blocking (using XMR) the ready signal that get into the fifo_arb so the transactions wont be able to get out. "),(0,a.kt)("h1",{id:"conclusion"},"Conclusion"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"our sequence is a generic one that all our tests are using it."),(0,a.kt)("li",{parentName:"ul"},"our DI checker is a simple yet a powerfull one, we found a lot of issues that were fixed and it assure us a reliable GK.\nIn order to verify smaller parts or protocols we added assertions and not a checkers, for instanse we use an assertion that checks if we are trying to read from an empty FIFO, our assertion_test verify that."),(0,a.kt)("li",{parentName:"ul"},"Those tests are very robust and we changed the parameter to get into lot of corners in our design."),(0,a.kt)("li",{parentName:"ul"},"All in all this env helped us to find a lot of bugs and issues that were in the origin design and it gave us some confident about the reliability of our design.")))}u.isMDXComponent=!0}}]);