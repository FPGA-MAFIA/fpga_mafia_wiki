"use strict";(self.webpackChunkmy_docs=self.webpackChunkmy_docs||[]).push([[4032],{3905:(e,a,r)=>{r.d(a,{Zo:()=>d,kt:()=>u});var n=r(7294);function t(e,a,r){return a in e?Object.defineProperty(e,a,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[a]=r,e}function i(e,a){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var a=1;a<arguments.length;a++){var r=null!=arguments[a]?arguments[a]:{};a%2?i(Object(r),!0).forEach((function(a){t(e,a,r[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(r,a))}))}return e}function s(e,a){if(null==e)return{};var r,n,t=function(e,a){if(null==e)return{};var r,n,t={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],a.indexOf(r)>=0||(t[r]=e[r]);return t}(e,a);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],a.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(t[r]=e[r])}return t}var l=n.createContext({}),c=function(e){var a=n.useContext(l),r=a;return e&&(r="function"==typeof e?e(a):o(o({},a),e)),r},d=function(e){var a=c(e.components);return n.createElement(l.Provider,{value:a},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},y=n.forwardRef((function(e,a){var r=e.components,t=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=c(r),y=t,u=p["".concat(l,".").concat(y)]||p[y]||m[y]||i;return r?n.createElement(u,o(o({ref:a},d),{},{components:r})):n.createElement(u,o({ref:a},d))}));function u(e,a){var r=arguments,t=a&&a.mdxType;if("string"==typeof e||t){var i=r.length,o=new Array(i);o[0]=y;var s={};for(var l in a)hasOwnProperty.call(a,l)&&(s[l]=a[l]);s.originalType=e,s[p]="string"==typeof e?e:t,o[1]=s;for(var c=2;c<i;c++)o[c]=r[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}y.displayName="MDXCreateElement"},3825:(e,a,r)=>{r.r(a),r.d(a,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var n=r(7462),t=(r(7294),r(3905));const i={},o="Multiple dimensional arrays",s={unversionedId:"TFM/verilog/multi_dim_array",id:"TFM/verilog/multi_dim_array",title:"Multiple dimensional arrays",description:"Packed vs Unpacked",source:"@site/docs/TFM/verilog/multi_dim_array.md",sourceDirName:"TFM/verilog",slug:"/TFM/verilog/multi_dim_array",permalink:"/fpga_mafia_wiki/docs/TFM/verilog/multi_dim_array",draft:!1,editUrl:"https://github.com/FPGA-MAFIA/fpga_mafia_wiki/tree/main/docs/TFM/verilog/multi_dim_array.md",tags:[],version:"current",frontMatter:{},sidebar:"TFM",previous:{title:"SystemVerilog Types",permalink:"/fpga_mafia_wiki/docs/TFM/verilog/sv_types"},next:{title:"Coding Style",permalink:"/fpga_mafia_wiki/docs/TFM/verilog/coding_style"}},l={},c=[{value:"Packed vs Unpacked",id:"packed-vs-unpacked",level:2},{value:"structs &amp; multi-dimensional arrays",id:"structs--multi-dimensional-arrays",level:2}],d={toc:c},p="wrapper";function m(e){let{components:a,...r}=e;return(0,t.kt)(p,(0,n.Z)({},d,r,{components:a,mdxType:"MDXLayout"}),(0,t.kt)("h1",{id:"multiple-dimensional-arrays"},"Multiple dimensional arrays"),(0,t.kt)("h2",{id:"packed-vs-unpacked"},"Packed vs Unpacked"),(0,t.kt)("p",null,"In SystemVerilog, packed and unpacked arrays are used to represent different types of data storage.",(0,t.kt)("br",{parentName:"p"}),"\n","Packed arrays store data in a compact, contiguous block of memory, while unpacked arrays store data in separate, non-contiguous memory locations.",(0,t.kt)("br",{parentName:"p"}),"\n","Commonly Packed arrays are used when your signal is treated as a single element, while unpacked arrays are useful for storing arrays of a elements.",(0,t.kt)("br",{parentName:"p"}),"\n",'Two signals may be the same number of bits, but they are not the same "shape".  '),(0,t.kt)("p",null,"For example, the following code declares a packed,unpacked & mixed arrays of 4 bits:  "),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-systemverilog"},"// Packed array declaration\nlogic [3:0] packed_array;\n// Unpacked array declaration\nlogic unpacked_array [3:0];\n//mixed packed and unpacked array declaration:\nlogic [1:0] array_c [1:0];\n")),(0,t.kt)("p",null,(0,t.kt)("inlineCode",{parentName:"p"},"array_a")," is a packed array of 4 bits, while ",(0,t.kt)("inlineCode",{parentName:"p"},"array_b")," is an unpacked array of 4 bits.",(0,t.kt)("br",{parentName:"p"}),"\n","The mixed array ",(0,t.kt)("inlineCode",{parentName:"p"},"array_c")," is a two-dimensional array where each element is a packed array of 2 bits."),(0,t.kt)("p",null,"To assign values between a packed and an unpacked array, you need to explicitly access the bits of the packed array.",(0,t.kt)("br",{parentName:"p"}),"\n","This is because packed and unpacked arrays have different storage formats, and the bits of a packed array may be arranged in a different order than the bits of an unpacked array.",(0,t.kt)("br",{parentName:"p"}),"\n","For example, to assign the values of array_b to array_a, you can use a for loop to access each bit of the arrays and assign the values one by one:  "),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-systemverilog"},"always_comb begin\n  for(int i = 0; i < 4; i++) begin\n    array_a[i] = array_b[i];\n  end\nend\n")),(0,t.kt)("p",null,'To assign values from a mixed array to a packed array, you can use concatenation to combine the bits from the elements of the mixed array to match the correct "shape" of the packed array:  '),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-systemverilog"},"assign packed_array = {array_c[1][1:0], array_c[0][1:0]};\n")),(0,t.kt)("p",null,"In this example, the bits ","[1:0]"," of array_c","[1]"," and array_c","[0]"," are concatenated to form the 4-bit packed array packed_array."),(0,t.kt)("p",null,"Another example:"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-systemverilog"},'// 8-bit packed array (a single element)\nlogic [7:0] element_a;\nlogic [7:0] element_b;\nlogic [7:0] element_c;\nlogic [7:0] element_d;\n\n// unpacked array_1d with 10 elements. each element is 8-bit\nlogic [7:0] array_1d [9:0]\n// unpacked array_2d with 10x10=100 elements. each element is 8-bit\nlogic [7:0] array_2d [9:0][9:0];\n\n// ====== Example for legal assignments =====\n// assign an Element from the array to the entr\nassign element_a = array_2d[0][0];\n\n// assign element_b to array_2d to a specific entry\nassign array_2d[1][2] = element_b;\n\n// assign a row to the 1d array from the 2d array\nassign array_1d = array_2d[3];\n//same as: assign array_1d[9:0] = array_2d[3][9:0];\n\n// assign a column to the 1d array from the 2d array \n/// Note this wont work: "assign array_1d[9:0] = array_2d[9:0][5];"\nalways_comb begin\n  for(int i=0; i< 10; i++) begin\n    array_1d[i] = array_2d[i][5];\n  end//for\nend\n\n// Can access a specific bit from the element in the array\nlogic [1:0] specific_bits;\n// Example "array_2d[7][5][3:2]"\n// unpacked: [7]-row, [5]-col\n// packed [3:0]- specific bits from the element\nassign specific_bits[1:0] = array_2d[7][5][3:2]; \n\n//Note: the order of the brackets are:\n// 1. access the unpacked (left to right)\n// 2. access the packed (left to right)\nlogic [3:0][7:0] mixed_example [31:0][95:0];\n//accessing the MSB of this multi-dimensional array:\nassign the_msb = mixed_example[31][95][3][7];\n')),(0,t.kt)("h2",{id:"structs--multi-dimensional-arrays"},"structs & multi-dimensional arrays"),(0,t.kt)("p",null,"systemverilog Structs can also be used to create multi-dimensional arrays.\nMay be packed or unpacked. and me a vector of any struct type."))}m.isMDXComponent=!0}}]);