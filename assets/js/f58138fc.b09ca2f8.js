"use strict";(self.webpackChunkmy_docs=self.webpackChunkmy_docs||[]).push([[3865],{3905:(e,n,r)=>{r.d(n,{Zo:()=>s,kt:()=>f});var t=r(7294);function a(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function o(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,t)}return r}function c(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?o(Object(r),!0).forEach((function(n){a(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function i(e,n){if(null==e)return{};var r,t,a=function(e,n){if(null==e)return{};var r,t,a={},o=Object.keys(e);for(t=0;t<o.length;t++)r=o[t],n.indexOf(r)>=0||(a[r]=e[r]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(t=0;t<o.length;t++)r=o[t],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var _=t.createContext({}),p=function(e){var n=t.useContext(_),r=n;return e&&(r="function"==typeof e?e(n):c(c({},n),e)),r},s=function(e){var n=p(e.components);return t.createElement(_.Provider,{value:n},e.children)},l="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},u=t.forwardRef((function(e,n){var r=e.components,a=e.mdxType,o=e.originalType,_=e.parentName,s=i(e,["components","mdxType","originalType","parentName"]),l=p(r),u=a,f=l["".concat(_,".").concat(u)]||l[u]||m[u]||o;return r?t.createElement(f,c(c({ref:n},s),{},{components:r})):t.createElement(f,c({ref:n},s))}));function f(e,n){var r=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=r.length,c=new Array(o);c[0]=u;var i={};for(var _ in n)hasOwnProperty.call(n,_)&&(i[_]=n[_]);i.originalType=e,i[l]="string"==typeof e?e:a,c[1]=i;for(var p=2;p<o;p++)c[p]=r[p];return t.createElement.apply(null,c)}return t.createElement.apply(null,r)}u.displayName="MDXCreateElement"},1058:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>_,contentTitle:()=>c,default:()=>m,frontMatter:()=>o,metadata:()=>i,toc:()=>p});var t=r(7462),a=(r(7294),r(3905));const o={},c=void 0,i={unversionedId:"rvc/sc_core/sc_core_pkg",id:"rvc/sc_core/sc_core_pkg",title:"sc_core_pkg",description:"sccorepkg.sv file",source:"@site/docs/rvc/sc_core/sc_core_pkg.md",sourceDirName:"rvc/sc_core",slug:"/rvc/sc_core/sc_core_pkg",permalink:"/fpga_mafia_wiki/docs/rvc/sc_core/sc_core_pkg",draft:!1,editUrl:"https://github.com/FPGA-MAFIA/fpga_mafia_wiki/tree/main/docs/rvc/sc_core/sc_core_pkg.md",tags:[],version:"current",frontMatter:{},sidebar:"RISCV_Cores",previous:{title:"macros",permalink:"/fpga_mafia_wiki/docs/rvc/sc_core/macros"},next:{title:"sc_core",permalink:"/fpga_mafia_wiki/docs/rvc/sc_core/"}},_={},p=[{value:"sc_core_pkg.sv file",id:"sc_core_pkgsv-file",level:3}],s={toc:p},l="wrapper";function m(e){let{components:n,...r}=e;return(0,a.kt)(l,(0,t.Z)({},s,r,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h3",{id:"sc_core_pkgsv-file"},"sc_core_pkg.sv file"),(0,a.kt)("p",null,"That file contains the core's parameters and some typedef enumerators. Each core has its own file with these settings. ",(0,a.kt)("strong",{parentName:"p"},"The simple core, without any extra feature, only uses the first four memory parameters and all typdefs."),"   "),(0,a.kt)("p",null,"That file is located in ",(0,a.kt)("inlineCode",{parentName:"p"},"/source/sc_core/sc_core_pkg.sv")," folder.      "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"//-----------------------------------------------------------------------------\n// Title            : \n// Project          : \n//-----------------------------------------------------------------------------\n// File             : \n// Original Author  : \n// Code Owner       : \n// Created          : 11/2022\n//-----------------------------------------------------------------------------\n// Description :\n// \n//-----------------------------------------------------------------------------\n\n\n\n`ifndef SC_CORE_PKG_SV\n`define SC_CORE_PKG_SV\npackage sc_core_pkg;\n    \n\n\nparameter I_MEM_SIZE   = 'h2000;\nparameter I_MEM_OFFSET = 'h0;\nparameter D_MEM_SIZE   = 'h100000;\nparameter D_MEM_OFFSET = 'h2000;\n\nparameter I_MEM_MSB   = I_MEM_SIZE-1;               // I_MEM   0x0    - 0x3FFF\nparameter D_MEM_MSB   = D_MEM_SIZE+D_MEM_OFFSET-1;  // D_MEM   0x4000 - 0x6FFF\nparameter CR_MEM_MSB  = 'h5000-1;                   // CR_MEM  0x7000 - 0x7FFF\nparameter VGA_MEM_MSB = 'h11600-1;                  // VGA_MEM 0x8000 - 0x115FF\n// Region bits\nparameter LSB_REGION = 0;\nparameter MSB_REGION = 15;\n\n// VGA Region bits\nparameter VGA_MSB_REGION = 19;\n\n// Encoded regions\nparameter I_MEM_REGION_FLOOR   = 'h0                    ;\nparameter I_MEM_REGION_ROOF    = I_MEM_MSB              ;\n\nparameter D_MEM_REGION_FLOOR   = I_MEM_REGION_ROOF  + 1 ;\nparameter D_MEM_REGION_ROOF    = D_MEM_MSB              ;\n\nparameter CR_MEM_REGION_FLOOR  = D_MEM_REGION_ROOF  + 1 ;\nparameter CR_MEM_REGION_ROOF   = CR_MEM_MSB             ;\n\nparameter VGA_MEM_REGION_FLOOR = CR_MEM_REGION_ROOF + 1 ;\nparameter VGA_MEM_REGION_ROOF  = VGA_MEM_MSB            ;\n\n// define data memory sizes\nparameter SIZE_D_MEM       = D_MEM_REGION_ROOF - D_MEM_REGION_FLOOR + 1; \n\n// define VGA memory sizes\nparameter SIZE_VGA_MEM       = 38400; \n\n\nparameter NOP = 32'b000000000000000000000000010011; // addi x0 , x0 , 0\n\ntypedef enum logic [2:0] {\n    U_TYPE = 3'b000 , \n    I_TYPE = 3'b001 ,  \n    S_TYPE = 3'b010 ,     \n    B_TYPE = 3'b011 , \n    J_TYPE = 3'b100 \n} t_immediate ;\n\ntypedef enum logic [3:0] {\n    ADD  = 4'b0000 ,\n    SUB  = 4'b1000 ,\n    SLT  = 4'b0010 ,\n    SLTU = 4'b0011 ,\n    SLL  = 4'b0001 , \n    SRL  = 4'b0101 ,\n    SRA  = 4'b1101 ,\n    XOR  = 4'b0100 ,\n    OR   = 4'b0110 ,\n    AND  = 4'b0111 ,\n    IN_2 = 4'b1111\n} t_alu_op ;\n\ntypedef enum logic [2:0] {\n   BEQ  = 3'b000 ,\n   BNE  = 3'b001 ,\n   BLT  = 3'b100 ,\n   BGE  = 3'b101 ,\n   BLTU = 3'b110 ,\n   BGEU = 3'b111\n} t_branch_type ;\n\ntypedef enum logic [6:0] {\n   LUI    = 7'b0110111 ,\n   AUIPC  = 7'b0010111 ,\n   JAL    = 7'b1101111 ,\n   JALR   = 7'b1100111 ,\n   BRANCH = 7'b1100011 ,\n   LOAD   = 7'b0000011 ,\n   STORE  = 7'b0100011 ,\n   I_OP   = 7'b0010011 ,\n   R_OP   = 7'b0110011 ,\n   FENCE  = 7'b0001111 ,\n   SYSCAL = 7'b1110011\n} t_opcode ;\n\n\nendpackage\n\n`endif //SC_CORE_PKG_SV\n\n")),(0,a.kt)("p",null,"For example let's take a look at the following typedef enumerator. All the other typedef enumerators functionality are similar to this one.  "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"typedef enum logic [6:0] {\n   LUI    = 7'b0110111 ,\n   AUIPC  = 7'b0010111 ,\n   JAL    = 7'b1101111 ,\n   JALR   = 7'b1100111 ,\n   BRANCH = 7'b1100011 ,\n   LOAD   = 7'b0000011 ,\n   STORE  = 7'b0100011 ,\n   I_OP   = 7'b0010011 ,\n   R_OP   = 7'b0110011 ,\n   FENCE  = 7'b0001111 ,\n   SYSCAL = 7'b1110011\n} t_opcode ;\n")),(0,a.kt)("p",null,"Here we define the ",(0,a.kt)("inlineCode",{parentName:"p"},"t_opcode")," enumerator, each enumerator has a name and a value. For example, the ",(0,a.kt)("inlineCode",{parentName:"p"},"LUI")," enumerator has the value ",(0,a.kt)("inlineCode",{parentName:"p"},"7'b0110111"),". We can access each value by using the enumerator name or value. Such coding style is very useful for readability."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"If its your first time working with typedef enumerators, we suggest you to read about it in the ",(0,a.kt)("a",{parentName:"li",href:"/fpga_mafia_wiki/docs/TFM/verilog/sv_types"},"typedef enumerators"),' link and "play" with it by yourself.')))}m.isMDXComponent=!0}}]);