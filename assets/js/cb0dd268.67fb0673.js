"use strict";(self.webpackChunkmy_docs=self.webpackChunkmy_docs||[]).push([[8042],{3905:(t,e,a)=>{a.d(e,{Zo:()=>s,kt:()=>h});var n=a(7294);function r(t,e,a){return e in t?Object.defineProperty(t,e,{value:a,enumerable:!0,configurable:!0,writable:!0}):t[e]=a,t}function l(t,e){var a=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),a.push.apply(a,n)}return a}function i(t){for(var e=1;e<arguments.length;e++){var a=null!=arguments[e]?arguments[e]:{};e%2?l(Object(a),!0).forEach((function(e){r(t,e,a[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(a,e))}))}return t}function p(t,e){if(null==t)return{};var a,n,r=function(t,e){if(null==t)return{};var a,n,r={},l=Object.keys(t);for(n=0;n<l.length;n++)a=l[n],e.indexOf(a)>=0||(r[a]=t[a]);return r}(t,e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(t);for(n=0;n<l.length;n++)a=l[n],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(t,a)&&(r[a]=t[a])}return r}var d=n.createContext({}),o=function(t){var e=n.useContext(d),a=e;return t&&(a="function"==typeof t?t(e):i(i({},e),t)),a},s=function(t){var e=o(t.components);return n.createElement(d.Provider,{value:e},t.children)},u="mdxType",c={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},m=n.forwardRef((function(t,e){var a=t.components,r=t.mdxType,l=t.originalType,d=t.parentName,s=p(t,["components","mdxType","originalType","parentName"]),u=o(a),m=r,h=u["".concat(d,".").concat(m)]||u[m]||c[m]||l;return a?n.createElement(h,i(i({ref:e},s),{},{components:a})):n.createElement(h,i({ref:e},s))}));function h(t,e){var a=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var l=a.length,i=new Array(l);i[0]=m;var p={};for(var d in e)hasOwnProperty.call(e,d)&&(p[d]=e[d]);p.originalType=t,p[u]="string"==typeof t?t:r,i[1]=p;for(var o=2;o<l;o++)i[o]=a[o];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},4882:(t,e,a)=>{a.r(e),a.d(e,{assets:()=>d,contentTitle:()=>i,default:()=>c,frontMatter:()=>l,metadata:()=>p,toc:()=>o});var n=a(7462),r=(a(7294),a(3905));const l={},i="Pipe",p={unversionedId:"cache/MAS/pipe",id:"cache/MAS/pipe",title:"Pipe",description:"This module represents the data cache pipeline that efficiently handles cache operations, data hazards, tag comparisons, cache misses and communicates with other components. The pipeline consists of several stages, each responsible for specific tasks.",source:"@site/docs/cache/MAS/pipe.md",sourceDirName:"cache/MAS",slug:"/cache/MAS/pipe",permalink:"/fpga_mafia_wiki/docs/cache/MAS/pipe",draft:!1,editUrl:"https://github.com/FPGA-MAFIA/fpga_mafia_wiki/tree/main/docs/cache/MAS/pipe.md",tags:[],version:"current",frontMatter:{},sidebar:"Cache",previous:{title:"Data Cache - MAS",permalink:"/fpga_mafia_wiki/docs/cache/MAS/d_cache"},next:{title:"tag_data_arrays",permalink:"/fpga_mafia_wiki/docs/cache/MAS/tag_data_arrays"}},d={},o=[{value:"The pipe Stages",id:"the-pipe-stages",level:3},{value:"Pipe Block Diagram",id:"pipe-block-diagram",level:2},{value:"IO",id:"io",level:2},{value:"General IO",id:"general-io",level:3},{value:"pipe&lt;-&gt;tq IO",id:"pipe-tq-io",level:3},{value:"pipe&lt;-&gt;tag_array IO",id:"pipe-tag_array-io",level:3},{value:"pipe&lt;-&gt;data_array IO",id:"pipe-data_array-io",level:3},{value:"Strategy",id:"strategy",level:2},{value:"The struct contains the following fields:",id:"the-struct-contains-the-following-fields",level:5},{value:"Pipe Stages",id:"pipe-stages",level:2},{value:"Q1 - Set Lookup / Tag Array Lookup",id:"q1---set-lookup--tag-array-lookup",level:3},{value:"Q2 - Data Hazard Resolution, Tag Comparison, Allocation of Victim",id:"q2---data-hazard-resolution-tag-comparison-allocation-of-victim",level:3},{value:"Hazard Resolution",id:"hazard-resolution",level:4},{value:"Tag Comparison and Victim Allocation",id:"tag-comparison-and-victim-allocation",level:4},{value:"choose victim in case of cache fills.",id:"choose-victim-in-case-of-cache-fills",level:4},{value:"Update tag array",id:"update-tag-array",level:3},{value:"Read hit",id:"read-hit",level:4},{value:"Write hit",id:"write-hit",level:4},{value:"Fill",id:"fill",level:4},{value:"All are MRU - bit-flip pseudo MRU (Most Recently Used) policy",id:"all-are-mru---bit-flip-pseudo-mru-most-recently-used-policy",level:5},{value:"Data fetch",id:"data-fetch",level:3},{value:"Q3 - Update of Tag Array, Data Fetch, Cache Miss Handling",id:"q3---update-of-tag-array-data-fetch-cache-miss-handling",level:3}],s={toc:o},u="wrapper";function c(t){let{components:e,...a}=t;return(0,r.kt)(u,(0,n.Z)({},s,a,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"pipe"},"Pipe"),(0,r.kt)("p",null,"This module represents the data cache pipeline that efficiently handles cache operations, data hazards, tag comparisons, cache misses and communicates with other components. The pipeline consists of several stages, each responsible for specific tasks."),(0,r.kt)("h3",{id:"the-pipe-stages"},"The pipe Stages"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Q1 - Set Lookup / Tag Array Lookup"),(0,r.kt)("li",{parentName:"ul"},"Q2 - Data Hazard Resolution, Tag Comparison, Allocation of Victim"),(0,r.kt)("li",{parentName:"ul"},"Q3 - Update of Tag Array, Data Fetch, Cache Miss Handling")),(0,r.kt)("h2",{id:"pipe-block-diagram"},"Pipe Block Diagram"),(0,r.kt)("p",null,"TODO: Add block diagram"),(0,r.kt)("h2",{id:"io"},"IO"),(0,r.kt)("h3",{id:"general-io"},"General IO"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Signal Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Direction"),(0,r.kt)("th",{parentName:"tr",align:null},"Size"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"clk"),(0,r.kt)("td",{parentName:"tr",align:null},"Input"),(0,r.kt)("td",{parentName:"tr",align:null},"1 bit"),(0,r.kt)("td",{parentName:"tr",align:null},"Clock signal.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"rst"),(0,r.kt)("td",{parentName:"tr",align:null},"Input"),(0,r.kt)("td",{parentName:"tr",align:null},"1 bit"),(0,r.kt)("td",{parentName:"tr",align:null},"Reset signal.")))),(0,r.kt)("h3",{id:"pipe-tq-io"},"pipe<->tq IO"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Signal Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Direction"),(0,r.kt)("th",{parentName:"tr",align:null},"Size"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"pipe_lu_req_q1"),(0,r.kt)("td",{parentName:"tr",align:null},"Input"),(0,r.kt)("td",{parentName:"tr",align:null},"195 bits"),(0,r.kt)("td",{parentName:"tr",align:null},"Input request to the cache pipeline.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"pipe_lu_req_q1.valid"),(0,r.kt)("td",{parentName:"tr",align:null},"Input"),(0,r.kt)("td",{parentName:"tr",align:null},"1 bit"),(0,r.kt)("td",{parentName:"tr",align:null},"Valid bit for the input request.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"pipe_lu_req_q1.reg_id"),(0,r.kt)("td",{parentName:"tr",align:null},"Input"),(0,r.kt)("td",{parentName:"tr",align:null},"5 bits"),(0,r.kt)("td",{parentName:"tr",align:null},"Register ID of the input request.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"pipe_lu_req_q1.addr"),(0,r.kt)("td",{parentName:"tr",align:null},"Input"),(0,r.kt)("td",{parentName:"tr",align:null},"64 bits"),(0,r.kt)("td",{parentName:"tr",align:null},"Address of the input request.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"pipe_lu_req_q1.lu_op"),(0,r.kt)("td",{parentName:"tr",align:null},"Input"),(0,r.kt)("td",{parentName:"tr",align:null},"2 bits"),(0,r.kt)("td",{parentName:"tr",align:null},"Lookup operation of the input request.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"pipe_lu_req_q1.cl_data"),(0,r.kt)("td",{parentName:"tr",align:null},"Input"),(0,r.kt)("td",{parentName:"tr",align:null},"128 bits"),(0,r.kt)("td",{parentName:"tr",align:null},"Cache line data of the input request.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"pipe_early_lu_rsp_q2"),(0,r.kt)("td",{parentName:"tr",align:null},"Output"),(0,r.kt)("td",{parentName:"tr",align:null},"13 bits"),(0,r.kt)("td",{parentName:"tr",align:null},"Early response from the cache pipeline.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"pipe_lu_rsp_q3"),(0,r.kt)("td",{parentName:"tr",align:null},"Output"),(0,r.kt)("td",{parentName:"tr",align:null},"164 bits"),(0,r.kt)("td",{parentName:"tr",align:null},"Final response from the cache pipeline.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"cache2fm_req_q3"),(0,r.kt)("td",{parentName:"tr",align:null},"Output"),(0,r.kt)("td",{parentName:"tr",align:null},"154 bits"),(0,r.kt)("td",{parentName:"tr",align:null},"Request sent to the FM (Far Memory) interface.")))),(0,r.kt)("h3",{id:"pipe-tag_array-io"},"pipe<->tag_array IO"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Signal Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Direction"),(0,r.kt)("th",{parentName:"tr",align:null},"Size"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"rd_set_req_q1"),(0,r.kt)("td",{parentName:"tr",align:null},"Output"),(0,r.kt)("td",{parentName:"tr",align:null},"9 bits"),(0,r.kt)("td",{parentName:"tr",align:null},"Read request to the tag array.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"wr_data_set_q2"),(0,r.kt)("td",{parentName:"tr",align:null},"Output"),(0,r.kt)("td",{parentName:"tr",align:null},"41 bits"),(0,r.kt)("td",{parentName:"tr",align:null},"Write request to the tag array.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"pre_rd_data_set_rsp_q2"),(0,r.kt)("td",{parentName:"tr",align:null},"Input"),(0,r.kt)("td",{parentName:"tr",align:null},"44 bits"),(0,r.kt)("td",{parentName:"tr",align:null},"Previous read data response from the tag array.")))),(0,r.kt)("h3",{id:"pipe-data_array-io"},"pipe<->data_array IO"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Signal Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Direction"),(0,r.kt)("th",{parentName:"tr",align:null},"Size"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"rd_cl_req_q2"),(0,r.kt)("td",{parentName:"tr",align:null},"Output"),(0,r.kt)("td",{parentName:"tr",align:null},"10 bits"),(0,r.kt)("td",{parentName:"tr",align:null},"Read request to the data array.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"wr_data_cl_q3"),(0,r.kt)("td",{parentName:"tr",align:null},"Output"),(0,r.kt)("td",{parentName:"tr",align:null},"139 bits"),(0,r.kt)("td",{parentName:"tr",align:null},"Write request to the data array.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"pre_rd_data_cl_rsp_q3"),(0,r.kt)("td",{parentName:"tr",align:null},"Input"),(0,r.kt)("td",{parentName:"tr",align:null},"128 bit ss"),(0,r.kt)("td",{parentName:"tr",align:null},"Previous read data response from the data array.")))),(0,r.kt)("h2",{id:"strategy"},"Strategy"),(0,r.kt)("p",null,"We created a struct that represents the cache pipeline.",(0,r.kt)("br",{parentName:"p"}),"\n","In every pipe stage, we can access the struct to get the relevant information for the current stage + update the struct with the relevant information that was calculated in the current stage."),(0,r.kt)("h5",{id:"the-struct-contains-the-following-fields"},"The struct contains the following fields:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Field Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Size"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"lu_valid"),(0,r.kt)("td",{parentName:"tr",align:null},"1  bit"),(0,r.kt)("td",{parentName:"tr",align:null},"Indicates if the lookup (LU) operation is valid.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"lu_offset"),(0,r.kt)("td",{parentName:"tr",align:null},"4  bits"),(0,r.kt)("td",{parentName:"tr",align:null},"Offset within the cache line (from ",(0,r.kt)("inlineCode",{parentName:"td"},"t_offset"),").")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"lu_set"),(0,r.kt)("td",{parentName:"tr",align:null},"8  bits"),(0,r.kt)("td",{parentName:"tr",align:null},"Set index within the cache (from ",(0,r.kt)("inlineCode",{parentName:"td"},"t_set_address"),").")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"lu_tag"),(0,r.kt)("td",{parentName:"tr",align:null},"8  bits"),(0,r.kt)("td",{parentName:"tr",align:null},"Tag associated with the cache line (from ",(0,r.kt)("inlineCode",{parentName:"td"},"t_tag"),").")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"lu_op"),(0,r.kt)("td",{parentName:"tr",align:null},"2  bits"),(0,r.kt)("td",{parentName:"tr",align:null},"Specifies the LU operation type (from ",(0,r.kt)("inlineCode",{parentName:"td"},"t_lu_opcode"),").")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"lu_tq_id"),(0,r.kt)("td",{parentName:"tr",align:null},"3  bits"),(0,r.kt)("td",{parentName:"tr",align:null},"Transaction Queue (TQ) ID associated with the operation (from ",(0,r.kt)("inlineCode",{parentName:"td"},"t_tq_id"),").")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"hit"),(0,r.kt)("td",{parentName:"tr",align:null},"1  bit"),(0,r.kt)("td",{parentName:"tr",align:null},"Indicates if the LU operation resulted in a cache hit.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"miss"),(0,r.kt)("td",{parentName:"tr",align:null},"1  bit"),(0,r.kt)("td",{parentName:"tr",align:null},"Indicates if the LU operation resulted in a cache miss.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"mb_hit_cancel"),(0,r.kt)("td",{parentName:"tr",align:null},"1  bit"),(0,r.kt)("td",{parentName:"tr",align:null},"Indicates whether there's a MultiBank (MB) hit cancellation.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"set_ways_valid"),(0,r.kt)("td",{parentName:"tr",align:null},"4  bits"),(0,r.kt)("td",{parentName:"tr",align:null},"Valid bit for each cache way in the specified set.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"set_ways_modified"),(0,r.kt)("td",{parentName:"tr",align:null},"4  bits"),(0,r.kt)("td",{parentName:"tr",align:null},"Modified bit for each cache way in the specified set.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"set_ways_mru"),(0,r.kt)("td",{parentName:"tr",align:null},"4  bits"),(0,r.kt)("td",{parentName:"tr",align:null},"Most Recently Used (MRU) bit for each cache way in the specified set.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"set_ways_tags"),(0,r.kt)("td",{parentName:"tr",align:null},"32  bits"),(0,r.kt)("td",{parentName:"tr",align:null},"Tags for each cache way in the specified set.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"set_ways_victim"),(0,r.kt)("td",{parentName:"tr",align:null},"4  bits"),(0,r.kt)("td",{parentName:"tr",align:null},"Victim way selection in the specified set.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"set_ways_hit"),(0,r.kt)("td",{parentName:"tr",align:null},"4  bits"),(0,r.kt)("td",{parentName:"tr",align:null},"Indicates if there's a hit for each cache way in the specified set.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"set_ways_enc_hit"),(0,r.kt)("td",{parentName:"tr",align:null},"2  bits"),(0,r.kt)("td",{parentName:"tr",align:null},"Encoded hit information for the ways in the specified set.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"cl_data"),(0,r.kt)("td",{parentName:"tr",align:null},"128 bits"),(0,r.kt)("td",{parentName:"tr",align:null},"Cache line data (from ",(0,r.kt)("inlineCode",{parentName:"td"},"t_cl"),").")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"data"),(0,r.kt)("td",{parentName:"tr",align:null},"32 bits"),(0,r.kt)("td",{parentName:"tr",align:null},"Data associated with the LU operation.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"fill_modified"),(0,r.kt)("td",{parentName:"tr",align:null},"1 bit"),(0,r.kt)("td",{parentName:"tr",align:null},"Indicates if the cache line is modified during a fill operation.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"fill_rd"),(0,r.kt)("td",{parentName:"tr",align:null},"1 bit"),(0,r.kt)("td",{parentName:"tr",align:null},"Indicates if the fill operation is a read operation.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"reg_id"),(0,r.kt)("td",{parentName:"tr",align:null},"5 bits"),(0,r.kt)("td",{parentName:"tr",align:null},"Register ID associated with the operation (from ",(0,r.kt)("inlineCode",{parentName:"td"},"t_reg_id"),").")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"dirty_evict"),(0,r.kt)("td",{parentName:"tr",align:null},"1 bit"),(0,r.kt)("td",{parentName:"tr",align:null},"Indicates if a dirty eviction is requested.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"data_array_address"),(0,r.kt)("td",{parentName:"tr",align:null},"10 bits"),(0,r.kt)("td",{parentName:"tr",align:null},"Address within the cache data array.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"rd_indication"),(0,r.kt)("td",{parentName:"tr",align:null},"1 bit"),(0,r.kt)("td",{parentName:"tr",align:null},"Indicates if this operation is a read indication.")))),(0,r.kt)("h2",{id:"pipe-stages"},"Pipe Stages"),(0,r.kt)("p",null,"The \u201cPipe\u201d is a 3-stage pipeline that manages the tag array lookup (LU) & Cache access."),(0,r.kt)("h3",{id:"q1---set-lookup--tag-array-lookup"},"Q1 - Set Lookup / Tag Array Lookup"),(0,r.kt)("p",null,"In this stage, the module performs a set lookup and tag array lookup. It prepares the cache request by extracting relevant information from the input request.\nFeatures and Actions:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Extracts the set index from the input address."),(0,r.kt)("li",{parentName:"ul"},"Prepares the cache request by populating various fields."),(0,r.kt)("li",{parentName:"ul"},"Assigns signals to the tag array lookup request.")),(0,r.kt)("h3",{id:"q2---data-hazard-resolution-tag-comparison-allocation-of-victim"},"Q2 - Data Hazard Resolution, Tag Comparison, Allocation of Victim"),(0,r.kt)("p",null,"Stage Q2 is critical for hazard resolution, tag comparison, and determining the victim for cache allocation.\nUpdating the tag array."),(0,r.kt)("h4",{id:"hazard-resolution"},"Hazard Resolution"),(0,r.kt)("p",null,"In the case of valid access b2b to the same set, we need to forward a sampled version (Q3) of te previous tag array write, to be used as override of the read response from tag array.\nThis is due to the fact that the tag array write is not yet visible to the tag array read which took place in Q1."),(0,r.kt)("p",null,"TODO - insert a diagram of the hazard resolution"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Detects data hazards by checking if Q2 and Q3 access the same set.\nths is important due to the data being written to the  in Q3"),(0,r.kt)("li",{parentName:"ul"},"Resolves data hazards by forwarding the data from Q3 to Q2.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-systemverilog"},"assign hazard_detected_q2 = (cache_pipe_lu_q2.lu_set == cache_pipe_lu_q3.lu_set) && cache_pipe_lu_q3.lu_valid && cache_pipe_lu_q2.lu_valid;\n...\n\nassign rd_data_set_rsp_q2 = hazard_detected_q2 ? hazard_rd_data_set_rsp_q3 : pre_rd_data_set_rsp_q2;\n")),(0,r.kt)("h4",{id:"tag-comparison-and-victim-allocation"},"Tag Comparison and Victim Allocation"),(0,r.kt)("p",null,'After we have the "final" result of the tag lookup, we compares tags to identify if cache hits & which way.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-systemverilog"},"always_comb begin\n    for( int WAY =0; WAY<NUM_WAYS; WAY++) begin\n        way_tag_match_q2[WAY] = (rd_data_set_rsp_q2.tags[WAY] == cache_pipe_lu_q2.lu_tag)  && \n                                 rd_data_set_rsp_q2.valid[WAY] &&\n                                 cache_pipe_lu_q2.lu_valid ;\n    end\nend\n")),(0,r.kt)("h4",{id:"choose-victim-in-case-of-cache-fills"},"choose victim in case of cache fills."),(0,r.kt)("p",null,'In case of a fill, we need to allocate a victim.\nWe prioritize "free" ways.\nWhen all ways are occupied, we use a bit-flip pseudo MRU (Most Recently Used) policy to allocate a victim.'),(0,r.kt)("h3",{id:"update-tag-array"},"Update tag array"),(0,r.kt)("p",null,"In this stage, the module updates the tag array. The update process depends on different scenarios:"),(0,r.kt)("h4",{id:"read-hit"},"Read hit"),(0,r.kt)("p",null,"In the case of a read hit, the module updates the Most Recently Used information in the tag array. It ensures that the way that was just accessed becomes the MRU."),(0,r.kt)("h4",{id:"write-hit"},"Write hit"),(0,r.kt)("p",null,'When a write hits a cache line, the module updates both the MRU information and the "modified" status in the tag array. Additionally to the MRU, the modified bits are set for the way that was written to, indicating that its data has been modified.'),(0,r.kt)("h4",{id:"fill"},"Fill"),(0,r.kt)("p",null,"In the case of a cache fill, we will have differents updates:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The MRU is updated."),(0,r.kt)("li",{parentName:"ul"},"The valid status is set which indicate that it now contains valid data."),(0,r.kt)("li",{parentName:"ul"},"The tag information in the tag array is updated to match the tag of the incoming data."),(0,r.kt)("li",{parentName:"ul"},"If the fill operation includes modified data from the merge buffer, the modified status is set which indicate that it now holds modified data.")),(0,r.kt)("h5",{id:"all-are-mru---bit-flip-pseudo-mru-most-recently-used-policy"},"All are MRU - bit-flip pseudo MRU (Most Recently Used) policy"),(0,r.kt)("p",null,"Link to the wiki pseudo MRU policy: ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Pseudo-LRU#Bit-PLRU"},"https://en.wikipedia.org/wiki/Pseudo-LRU#Bit-PLRU"),"\nBit-PLRU stores one status bit for each cache line. These bits are called MRU-bits. Every access to a line sets its MRU-bit to 1, indicating that the line was recently used. Whenever the last remaining 0 bit of a set's status bits is set to 1, all other bits are reset to 0. At cache misses, the leftmost line whose MRU-bit is 0 is replaced."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-systemverilog"},"//-----------------------------\n// if all are MRU - need to bit flip and set the new allocation/ last hit\n//-----------------------------\nif(&(set_ways_mru_q2)) begin        \n    set_ways_mru_q2 = cache_pipe_lu_q2.hit ? cache_pipe_lu_q2.set_ways_hit    : //reset all, and set only the WR/RD Hit location\n                                             cache_pipe_lu_q2.set_ways_victim ; //reset all, and set only the WR/RD Hit location\nend\n")),(0,r.kt)("h3",{id:"data-fetch"},"Data fetch"),(0,r.kt)("p",null,"Now we determine if and where there was a cache hit, we can fetch the data from the data array."),(0,r.kt)("h3",{id:"q3---update-of-tag-array-data-fetch-cache-miss-handling"},"Q3 - Update of Tag Array, Data Fetch, Cache Miss Handling"),(0,r.kt)("p",null,"In the third stage, the module updates the tag array, fetches data from the data array, and handles cache misses."),(0,r.kt)("p",null,"Features and Actions:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Updates the tag array based on cache operations (read, write, fill)."),(0,r.kt)("li",{parentName:"ul"},"Fetches data from the data array."),(0,r.kt)("li",{parentName:"ul"},"Handles cache misses by sending fill requests to a far memory component."),(0,r.kt)("li",{parentName:"ul"},"Detects dirty eviction for modified cache lines and sends them to far memory.")))}c.isMDXComponent=!0}}]);